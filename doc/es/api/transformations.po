msgid ""
msgstr ""
"Project-Id-Version: matplotlib\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-01 17:05-0400\n"
"PO-Revision-Date: 2022-08-07 04:41\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: matplotlib\n"
"X-Crowdin-Project-ID: 502106\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /[qu4nt.matplotlib-doc-es] main/doc/en/api/transformations.po\n"
"X-Crowdin-File-ID: 1984\n"
"Language: es_ES\n"

#: ../../api/transformations.rst:3
msgid "``matplotlib.transforms``"
msgstr "``matplotlib.transforms``"

#: matplotlib.transforms:1 of
msgid "Matplotlib includes a framework for arbitrary geometric transformations that is used determine the final position of all elements drawn on the canvas."
msgstr "Matplotlib incluye un framework para transformaciones geométricas arbitrarias que se utiliza para determinar la posición final de todos los elementos dibujados en el lienzo."

#: matplotlib.transforms:5 of
msgid "Transforms are composed into trees of `TransformNode` objects whose actual value depends on their children.  When the contents of children change, their parents are automatically invalidated.  The next time an invalidated transform is accessed, it is recomputed to reflect those changes.  This invalidation/caching approach prevents unnecessary recomputations of transforms, and contributes to better interactive performance."
msgstr "Las transformaciones se componen en árboles de objetos `TransformNode` cuyo valor real depende de sus hijos.  Cuando el contenido de los hijos cambia, sus padres se invalidan automáticamente.  La siguiente vez que se accede a una transformación invalidada, se vuelve a calcular para reflejar esos cambios.  Este enfoque de invalidación/almacenamiento evita recálculos innecesarios de las transformaciones, y contribuye a un mejor rendimiento interactivo."

#: matplotlib.transforms:13 of
msgid "For example, here is a graph of the transform tree used to plot data to the graph:"
msgstr "Por ejemplo, aquí hay un gráfico del árbol de transformaciones utilizado para trazar los datos a la gráfica:"

#: matplotlib.transforms:18 of
msgid "The framework can be used for both affine and non-affine transformations.  However, for speed, we want use the backend renderers to perform affine transformations whenever possible. Therefore, it is possible to perform just the affine or non-affine part of a transformation on a set of data.  The affine is always assumed to occur after the non-affine.  For any transform::"
msgstr "El framework puede ser utilizado tanto para transformaciones afines como no afines.  Sin embargo, para la velocidad, queremos usar los renderizadores del backend para realizar transformaciones afines siempre que sea posible. Por lo tanto, es posible realizar sólo la parte afín o no afín de una transformación en un conjunto de datos.  Se supone que la parte afín siempre ocurre después de la parte no afín.  Para cualquier transformación::"

#: matplotlib.transforms:27 of
msgid "The backends are not expected to handle non-affine transformations themselves."
msgstr "No se espera que los backends manejen por sí mismos las transformaciones no afines."

#: matplotlib.transforms.Affine2D:1
#: matplotlib.transforms.AffineDeltaTransform:1
#: matplotlib.transforms.BboxTransform:1
#: matplotlib.transforms.BboxTransformFrom:1
#: matplotlib.transforms.BboxTransformTo:1
#: matplotlib.transforms.CompositeAffine2D:1
#: matplotlib.transforms.IdentityTransform:1
#: matplotlib.transforms.ScaledTranslation:1 of
msgid "Bases: :py:class:`matplotlib.transforms.Affine2DBase`"
msgstr "Bases: :py:class:`matplotlib.transforms.Affine2DBase`"

#: matplotlib.transforms.Affine2D:2 of
msgid "A mutable 2D affine transformation."
msgstr "Una transformación afín 2D mutable."

#: matplotlib.transforms.Affine2D:23 matplotlib.transforms.Affine2D.__init__:2
#: of
msgid "Initialize an Affine transform from a 3x3 numpy float array::"
msgstr "Inicializar una transformación Affine a partir de un arreglo de 3x3 flotadores de numpy::"

#: matplotlib.transforms.Affine2D:29 matplotlib.transforms.Affine2D.__init__:8
#: of
msgid "If *matrix* is None, initialize with the identity transform."
msgstr "Si *matriz* es None, se inicializa con la transformada de identidad."

#: matplotlib.transforms.Affine2D.__str__:2
#: matplotlib.transforms.Bbox.__str__:2
#: matplotlib.transforms._make_str_method.<locals>.<lambda>:2 of
msgid "Return str(self)."
msgstr "Devuelve str(self)."

#: matplotlib.transforms.Affine2D.clear:2 of
msgid "Reset the underlying matrix to the identity transform."
msgstr "Restablecer la matriz subyacente a la transformada de identidad."

#: matplotlib.transforms.Affine2D.from_values:2 of
msgid "Create a new Affine2D instance from the given values::"
msgstr "Crea una nueva instancia de Affine2D a partir de los valores dados::"

#: matplotlib.transforms.Affine2D.from_values:8
#: matplotlib.transforms.Affine2D.get_matrix:8
#: matplotlib.transforms.Affine2D.set_matrix:8 of
msgid "."
msgstr "."

#: matplotlib.transforms.Affine2D.get_matrix:2 of
msgid "Get the underlying transformation matrix as a 3x3 numpy array::"
msgstr "Obtener la matriz de transformación subyacente como un arreglo numpy de 3x3::"

#: matplotlib.transforms.Affine2D.identity:2 of
msgid "Return a new `Affine2D` object that is the identity transform."
msgstr "Devuelve un nuevo objeto `Affine2D` que es la transformada de identidad."

#: matplotlib.transforms.Affine2D.identity:4 of
msgid "Unless this transform will be mutated later on, consider using the faster `IdentityTransform` class instead."
msgstr "A menos que esta transformación vaya a ser mutada más adelante, considera usar la clase más rápida `IdentityTransform` en su lugar."

#: matplotlib.transforms.Affine2D.rotate:2 of
msgid "Add a rotation (in radians) to this transform in place."
msgstr "Añade una rotación (en radianes) a esta transformación en su lugar."

#: matplotlib.transforms.Affine2D.rotate:4
#: matplotlib.transforms.Affine2D.rotate_around:4
#: matplotlib.transforms.Affine2D.rotate_deg:4
#: matplotlib.transforms.Affine2D.rotate_deg_around:4
#: matplotlib.transforms.Affine2D.scale:7 matplotlib.transforms.Affine2D.skew:7
#: matplotlib.transforms.Affine2D.skew_deg:7
#: matplotlib.transforms.Affine2D.translate:4 of
msgid "Returns *self*, so this method can easily be chained with more calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate` and :meth:`scale`."
msgstr "Devuelve *self*, por lo que este método puede encadenarse fácilmente con más llamadas a :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate` y :meth:`scale`."

#: matplotlib.transforms.Affine2D.rotate_around:2 of
msgid "Add a rotation (in radians) around the point (x, y) in place."
msgstr "Añade una rotación (en radianes) alrededor del punto (x, y) en su lugar."

#: matplotlib.transforms.Affine2D.rotate_deg:2 of
msgid "Add a rotation (in degrees) to this transform in place."
msgstr "Añade una rotación (en grados) a esta transformación en su lugar."

#: matplotlib.transforms.Affine2D.rotate_deg_around:2 of
msgid "Add a rotation (in degrees) around the point (x, y) in place."
msgstr "Añade una rotación (en grados) alrededor del punto (x, y) en su lugar."

#: matplotlib.transforms.Affine2D.scale:2 of
msgid "Add a scale in place."
msgstr "Añadir una escala en su lugar."

#: matplotlib.transforms.Affine2D.scale:4 of
msgid "If *sy* is None, the same scale is applied in both the *x*- and *y*-directions."
msgstr "Si *sy* es None, se aplica la misma escala en las direcciones *x* y *y*."

#: matplotlib.transforms.Affine2D.set:2 of
msgid "Set this transformation from the frozen copy of another `Affine2DBase` object."
msgstr "Establecer esta transformación desde la copia congelada de otro objeto `Affine2DBase`."

#: matplotlib.transforms.Affine2D.set_matrix:2 of
msgid "Set the underlying transformation matrix from a 3x3 numpy array::"
msgstr "Establecer la matriz de transformación subyacente de un arreglo de 3x3 numpy::"

#: matplotlib.transforms.Affine2D.skew:2
#: matplotlib.transforms.Affine2D.skew_deg:2 of
msgid "Add a skew in place."
msgstr "Añade un skew en su lugar."

#: matplotlib.transforms.Affine2D.skew:4 of
msgid "*xShear* and *yShear* are the shear angles along the *x*- and *y*-axes, respectively, in radians."
msgstr "*xShear* y *yShear* son los ángulos de cizalladura a lo largo de los ejes *x* y *y*, respectivamente, en radianes."

#: matplotlib.transforms.Affine2D.skew_deg:4 of
msgid "*xShear* and *yShear* are the shear angles along the *x*- and *y*-axes, respectively, in degrees."
msgstr "*xShear* y *yShear* son los ángulos de corte a lo largo de los ejes *x* e *y*, respectivamente, en grados."

#: matplotlib.transforms.Affine2D.translate:2 of
msgid "Add a translation in place."
msgstr "Añadir una traducción en su lugar."

#: matplotlib.transforms.Affine2DBase:1 of
msgid "Bases: :py:class:`matplotlib.transforms.AffineBase`"
msgstr "Bases: :py:class:`matplotlib.transforms.AffineBase`"

#: matplotlib.transforms.Affine2DBase:2 of
msgid "The base class of all 2D affine transformations."
msgstr "La clase base de todas las transformaciones afines 2D."

#: matplotlib.transforms.Affine2DBase:4 of
msgid "2D affine transformations are performed using a 3x3 numpy array::"
msgstr "\n"
"Las transformaciones afines 2D se realizan utilizando un arreglo numpy de 3x3::"

#: matplotlib.transforms.Affine2DBase:10 of
msgid "This class provides the read-only interface.  For a mutable 2D affine transformation, use `Affine2D`."
msgstr "Esta clase proporciona la interfaz de sólo lectura.  Para una transformación afín 2D mutable, utilice `Affine2D`."

#: matplotlib.transforms.Affine2DBase:13 of
msgid "Subclasses of this class will generally only need to override a constructor and :meth:`get_matrix` that generates a custom 3x3 matrix."
msgstr "\n"
"Las subclases de esta clase por lo general sólo tendrán que anular un constructor y :meth:`get_matrix` que genera una matriz 3x3 personalizada."

#: matplotlib.transforms.Affine2DBase
#: matplotlib.transforms.Affine2DBase.transform_affine
#: matplotlib.transforms.AffineBase matplotlib.transforms.AffineBase.__init__
#: matplotlib.transforms.AffineBase.transform
#: matplotlib.transforms.AffineBase.transform_affine
#: matplotlib.transforms.AffineBase.transform_non_affine
#: matplotlib.transforms.AffineDeltaTransform
#: matplotlib.transforms.AffineDeltaTransform.__init__
#: matplotlib.transforms.Bbox matplotlib.transforms.Bbox.__init__
#: matplotlib.transforms.Bbox.from_extents
#: matplotlib.transforms.Bbox.update_from_data_x
#: matplotlib.transforms.Bbox.update_from_data_xy
#: matplotlib.transforms.Bbox.update_from_data_y
#: matplotlib.transforms.Bbox.update_from_path matplotlib.transforms.BboxBase
#: matplotlib.transforms.BboxBase.anchored
#: matplotlib.transforms.BboxBase.count_contains
#: matplotlib.transforms.BboxBase.count_overlaps
#: matplotlib.transforms.BboxBase.fully_overlaps
#: matplotlib.transforms.BboxBase.overlaps
#: matplotlib.transforms.BboxTransformFrom
#: matplotlib.transforms.BboxTransformFrom.__init__
#: matplotlib.transforms.BlendedGenericTransform.transform_non_affine
#: matplotlib.transforms.CompositeGenericTransform.transform_affine
#: matplotlib.transforms.CompositeGenericTransform.transform_non_affine
#: matplotlib.transforms.IdentityTransform
#: matplotlib.transforms.IdentityTransform.transform
#: matplotlib.transforms.IdentityTransform.transform_affine
#: matplotlib.transforms.IdentityTransform.transform_non_affine
#: matplotlib.transforms.LockableBbox
#: matplotlib.transforms.LockableBbox.__init__
#: matplotlib.transforms.ScaledTranslation
#: matplotlib.transforms.ScaledTranslation.__init__
#: matplotlib.transforms.Transform matplotlib.transforms.Transform.transform
#: matplotlib.transforms.Transform.transform_affine
#: matplotlib.transforms.Transform.transform_angles
#: matplotlib.transforms.Transform.transform_non_affine
#: matplotlib.transforms.TransformNode
#: matplotlib.transforms.TransformNode.__init__
#: matplotlib.transforms.TransformedBbox
#: matplotlib.transforms.TransformedBbox.__init__
#: matplotlib.transforms.TransformedPatchPath
#: matplotlib.transforms.TransformedPatchPath.__init__
#: matplotlib.transforms.TransformedPath
#: matplotlib.transforms.TransformedPath.__init__
#: matplotlib.transforms.interval_contains
#: matplotlib.transforms.interval_contains_open
#: matplotlib.transforms.nonsingular matplotlib.transforms.offset_copy of
msgid "Parameters"
msgstr "Parámetros"

#: matplotlib.transforms.Affine2DBase:55 matplotlib.transforms.AffineBase:44
#: matplotlib.transforms.AffineBase.__init__:23
#: matplotlib.transforms.AffineDeltaTransform:55
#: matplotlib.transforms.AffineDeltaTransform.__init__:23
#: matplotlib.transforms.BboxBase:50 matplotlib.transforms.BboxTransformFrom:45
#: matplotlib.transforms.BboxTransformFrom.__init__:23
#: matplotlib.transforms.IdentityTransform:45
#: matplotlib.transforms.ScaledTranslation:45
#: matplotlib.transforms.ScaledTranslation.__init__:23
#: matplotlib.transforms.Transform:68 matplotlib.transforms.TransformNode:47
#: matplotlib.transforms.TransformNode.__init__:23 of
msgid "**shorthand_name**"
msgstr "**shorthand_name**"

#: of
msgid "str"
msgstr "str"

#: matplotlib.transforms.Affine2DBase:40 matplotlib.transforms.AffineBase:29
#: matplotlib.transforms.AffineBase.__init__:8
#: matplotlib.transforms.AffineDeltaTransform:40
#: matplotlib.transforms.AffineDeltaTransform.__init__:8
#: matplotlib.transforms.BboxBase:35 matplotlib.transforms.BboxTransformFrom:30
#: matplotlib.transforms.BboxTransformFrom.__init__:8
#: matplotlib.transforms.IdentityTransform:30
#: matplotlib.transforms.ScaledTranslation:30
#: matplotlib.transforms.ScaledTranslation.__init__:8
#: matplotlib.transforms.Transform:53 matplotlib.transforms.TransformNode:32
#: matplotlib.transforms.TransformNode.__init__:8 of
msgid "A string representing the \"name\" of the transform. The name carries no significance other than to improve the readability of ``str(transform)`` when DEBUG=True."
msgstr "Una cadena que representa el \"nombre\" de la transformación. El nombre no tiene más significado que el de mejorar la legibilidad de ``str(transform)`` cuando DEBUG=True."

#: matplotlib.transforms.Affine2DBase.frozen:2
#: matplotlib.transforms.BlendedGenericTransform.frozen:2
#: matplotlib.transforms.CompositeGenericTransform.frozen:2
#: matplotlib.transforms.IdentityTransform.frozen:2
#: matplotlib.transforms.TransformNode.frozen:2
#: matplotlib.transforms.TransformWrapper.frozen:2 of
msgid "Return a frozen copy of this transform node.  The frozen copy will not be updated when its children change.  Useful for storing a previously known state of a transform where ``copy.deepcopy()`` might normally be used."
msgstr "Devuelve una copia congelada de este nodo de transformación.  La copia congelada no se actualizará cuando sus hijos cambien.  Útil para almacenar un estado previamente conocido de una transformación donde ``copy.deepcopy()`` podría usarse normalmente."

#: ../../docstring matplotlib.transforms.Affine2DBase.has_inverse:2
#: matplotlib.transforms.Transform.has_inverse:2 of
msgid "True if this transform has a corresponding inverse transform."
msgstr "Verdadero si esta transformación tiene una transformación inversa correspondiente."

#: ../../docstring matplotlib.transforms.Affine2DBase.input_dims:2
#: matplotlib.transforms.BlendedGenericTransform.input_dims:2
#: matplotlib.transforms.Transform.input_dims:2 of
msgid "The number of input dimensions of this transform. Must be overridden (with integers) in the subclass."
msgstr "El número de dimensiones de entrada de esta transformación. Debe ser sobrescrito (con enteros) en la subclase."

#: matplotlib.transforms.Affine2DBase.inverted:2
#: matplotlib.transforms.BlendedGenericTransform.inverted:2
#: matplotlib.transforms.CompositeGenericTransform.inverted:2
#: matplotlib.transforms.IdentityTransform.inverted:2
#: matplotlib.transforms.Transform.inverted:2 of
msgid "Return the corresponding inverse transformation."
msgstr "Devuelve la transformación inversa correspondiente."

#: matplotlib.transforms.Affine2DBase.inverted:4
#: matplotlib.transforms.BlendedGenericTransform.inverted:4
#: matplotlib.transforms.CompositeGenericTransform.inverted:4
#: matplotlib.transforms.IdentityTransform.inverted:4
#: matplotlib.transforms.Transform.inverted:4 of
msgid "It holds ``x == self.inverted().transform(self.transform(x))``."
msgstr "Sostiene ``x == self.inverted().transform(self.transform(x))``."

#: matplotlib.transforms.Affine2DBase.inverted:6
#: matplotlib.transforms.BlendedGenericTransform.inverted:6
#: matplotlib.transforms.CompositeGenericTransform.inverted:6
#: matplotlib.transforms.IdentityTransform.inverted:6
#: matplotlib.transforms.Transform.inverted:6 of
msgid "The return value of this method should be treated as temporary.  An update to *self* does not cause a corresponding update to its inverted copy."
msgstr "El valor de retorno de este método debe ser tratado como temporal.  Una actualización de *self* no provoca la correspondiente actualización de su copia invertida."

#: matplotlib.transforms.Affine2DBase.is_separable:2
#: matplotlib.transforms.BlendedGenericTransform.has_inverse:2
#: matplotlib.transforms.BlendedGenericTransform.is_affine:2
#: matplotlib.transforms.CompositeGenericTransform.has_inverse:2
#: matplotlib.transforms.CompositeGenericTransform.is_affine:2
#: matplotlib.transforms.CompositeGenericTransform.is_separable:2
#: matplotlib.transforms.TransformWrapper.has_inverse:2
#: matplotlib.transforms.TransformWrapper.is_affine:2
#: matplotlib.transforms.TransformWrapper.is_separable:2 of
msgid "bool(x) -> bool"
msgstr "bool(x) -> bool"

#: matplotlib.transforms.Affine2DBase.is_separable:4
#: matplotlib.transforms.BlendedGenericTransform.has_inverse:4
#: matplotlib.transforms.BlendedGenericTransform.is_affine:4
#: matplotlib.transforms.CompositeGenericTransform.has_inverse:4
#: matplotlib.transforms.CompositeGenericTransform.is_affine:4
#: matplotlib.transforms.CompositeGenericTransform.is_separable:4
#: matplotlib.transforms.TransformWrapper.has_inverse:4
#: matplotlib.transforms.TransformWrapper.is_affine:4
#: matplotlib.transforms.TransformWrapper.is_separable:4 of
msgid "Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed."
msgstr "Devuelve True cuando el argumento x es verdadero, False en caso contrario. Los builtins True y False son las dos únicas instancias de la clase bool. La clase bool es una subclase de la clase int, y no puede ser subclasificada."

#: ../../docstring matplotlib.transforms.Affine2DBase.output_dims:2
#: matplotlib.transforms.BlendedGenericTransform.output_dims:2
#: matplotlib.transforms.Transform.output_dims:2 of
msgid "The number of output dimensions of this transform. Must be overridden (with integers) in the subclass."
msgstr "El número de dimensiones de salida de esta transformación. Debe ser sobrescrito (con enteros) en la subclase."

#: matplotlib.transforms.Affine2DBase.to_values:2 of
msgid "Return the values of the matrix as an ``(a, b, c, d, e, f)`` tuple."
msgstr "Devuelve los valores de la matriz como una tupla ``(a, b, c, d, e, f)``."

#: matplotlib.transforms.Affine2DBase.transform_affine:2
#: matplotlib.transforms.AffineBase.transform_affine:2
#: matplotlib.transforms.CompositeGenericTransform.transform_affine:2
#: matplotlib.transforms.IdentityTransform.transform_affine:2
#: matplotlib.transforms.Transform.transform_affine:2 of
msgid "Apply only the affine part of this transformation on the given array of values."
msgstr "Aplica sólo la parte afín de esta transformación sobre el arreglo de valores dado."

#: matplotlib.transforms.Affine2DBase.transform_affine:5
#: matplotlib.transforms.AffineBase.transform_affine:5
#: matplotlib.transforms.AffineBase.transform_non_affine:4
#: matplotlib.transforms.BlendedGenericTransform.transform_non_affine:4
#: matplotlib.transforms.CompositeGenericTransform.transform_affine:5
#: matplotlib.transforms.CompositeGenericTransform.transform_non_affine:4
#: matplotlib.transforms.IdentityTransform.transform_affine:5
#: matplotlib.transforms.IdentityTransform.transform_non_affine:4
#: matplotlib.transforms.Transform.transform_affine:5
#: matplotlib.transforms.Transform.transform_non_affine:4 of
msgid "``transform(values)`` is always equivalent to ``transform_affine(transform_non_affine(values))``."
msgstr "``transform(valores)`` siempre es equivalente a ``transform_affine(transform_non_affine(valores))``."

#: matplotlib.transforms.Affine2DBase.transform_affine:8
#: matplotlib.transforms.AffineBase.transform_affine:8
#: matplotlib.transforms.CompositeGenericTransform.transform_affine:8
#: matplotlib.transforms.IdentityTransform.transform_affine:8
#: matplotlib.transforms.Transform.transform_affine:8 of
msgid "In non-affine transformations, this is generally a no-op.  In affine transformations, this is equivalent to ``transform(values)``."
msgstr "En las transformaciones no afines, esto es generalmente un no-op.  En las transformaciones afines, esto es equivalente a ``transform(values)``."

#: matplotlib.transforms.Affine2DBase.transform_affine:16
#: matplotlib.transforms.AffineBase.transform:9
#: matplotlib.transforms.AffineBase.transform_affine:16
#: matplotlib.transforms.AffineBase.transform_non_affine:15
#: matplotlib.transforms.BlendedGenericTransform.transform_non_affine:15
#: matplotlib.transforms.CompositeGenericTransform.transform_affine:16
#: matplotlib.transforms.CompositeGenericTransform.transform_non_affine:15
#: matplotlib.transforms.IdentityTransform.transform:9
#: matplotlib.transforms.IdentityTransform.transform_affine:16
#: matplotlib.transforms.IdentityTransform.transform_non_affine:15
#: matplotlib.transforms.Transform.transform:9
#: matplotlib.transforms.Transform.transform_affine:16
#: matplotlib.transforms.Transform.transform_non_affine:15 of
msgid "**values**"
msgstr "**valores**"

#: matplotlib.transforms.Affine2DBase.transform_affine:34
#: matplotlib.transforms.AffineBase.transform:27
#: matplotlib.transforms.AffineBase.transform_affine:34
#: matplotlib.transforms.AffineBase.transform_non_affine:33
#: matplotlib.transforms.BlendedGenericTransform.transform_non_affine:33
#: matplotlib.transforms.CompositeGenericTransform.transform_affine:34
#: matplotlib.transforms.CompositeGenericTransform.transform_non_affine:33
#: matplotlib.transforms.IdentityTransform.transform:27
#: matplotlib.transforms.IdentityTransform.transform_affine:34
#: matplotlib.transforms.IdentityTransform.transform_non_affine:33
#: matplotlib.transforms.Transform.transform:27
#: matplotlib.transforms.Transform.transform_affine:34
#: matplotlib.transforms.Transform.transform_non_affine:33 of
msgid "array"
msgstr "array"

#: matplotlib.transforms.Affine2DBase.transform_affine:15
#: matplotlib.transforms.AffineBase.transform:8
#: matplotlib.transforms.AffineBase.transform_affine:15
#: matplotlib.transforms.AffineBase.transform_non_affine:14
#: matplotlib.transforms.BlendedGenericTransform.transform_non_affine:14
#: matplotlib.transforms.CompositeGenericTransform.transform_affine:15
#: matplotlib.transforms.CompositeGenericTransform.transform_non_affine:14
#: matplotlib.transforms.IdentityTransform.transform:8
#: matplotlib.transforms.IdentityTransform.transform_affine:15
#: matplotlib.transforms.IdentityTransform.transform_non_affine:14
#: matplotlib.transforms.Transform.transform:8
#: matplotlib.transforms.Transform.transform_affine:15
#: matplotlib.transforms.Transform.transform_non_affine:14 of
msgid "The input values as NumPy array of length :attr:`input_dims` or shape (N x :attr:`input_dims`)."
msgstr "Los valores de entrada como arreglo NumPy de longitud :attr:`input_dims` o forma (N x :attr:`input_dims`)."

#: matplotlib.transforms.Affine2DBase.transform_affine
#: matplotlib.transforms.AffineBase.transform
#: matplotlib.transforms.AffineBase.transform_affine
#: matplotlib.transforms.AffineBase.transform_non_affine
#: matplotlib.transforms.BlendedGenericTransform.transform_non_affine
#: matplotlib.transforms.CompositeGenericTransform.transform_affine
#: matplotlib.transforms.CompositeGenericTransform.transform_non_affine
#: matplotlib.transforms.IdentityTransform.transform
#: matplotlib.transforms.IdentityTransform.transform_affine
#: matplotlib.transforms.IdentityTransform.transform_non_affine
#: matplotlib.transforms.Transform.transform
#: matplotlib.transforms.Transform.transform_affine
#: matplotlib.transforms.Transform.transform_angles
#: matplotlib.transforms.Transform.transform_non_affine
#: matplotlib.transforms.interval_contains
#: matplotlib.transforms.interval_contains_open
#: matplotlib.transforms.nonsingular matplotlib.transforms.offset_copy of
msgid "Returns"
msgstr "Devuelve"

#: matplotlib.transforms.Affine2DBase.transform_affine:21
#: matplotlib.transforms.AffineBase.transform:14
#: matplotlib.transforms.AffineBase.transform_affine:21
#: matplotlib.transforms.AffineBase.transform_non_affine:20
#: matplotlib.transforms.BlendedGenericTransform.transform_non_affine:20
#: matplotlib.transforms.CompositeGenericTransform.transform_affine:21
#: matplotlib.transforms.CompositeGenericTransform.transform_non_affine:20
#: matplotlib.transforms.IdentityTransform.transform:14
#: matplotlib.transforms.IdentityTransform.transform_affine:21
#: matplotlib.transforms.IdentityTransform.transform_non_affine:20
#: matplotlib.transforms.Transform.transform:14
#: matplotlib.transforms.Transform.transform_affine:21
#: matplotlib.transforms.Transform.transform_non_affine:20 of
msgid "The output values as NumPy array of length :attr:`input_dims` or shape (N x :attr:`output_dims`), depending on the input."
msgstr "Los valores de salida como arreglo NumPy de longitud :attr:`input_dims` o forma (N x :attr:`output_dims`), dependiendo de la entrada."

#: matplotlib.transforms.AffineBase:1
#: matplotlib.transforms.CompositeGenericTransform:1
#: matplotlib.transforms.TransformWrapper:1 of
msgid "Bases: :py:class:`matplotlib.transforms.Transform`"
msgstr "Bases: :py:class:`matplotlib.transforms.Transform`"

#: matplotlib.transforms.AffineBase:2 of
msgid "The base class of all affine transformations of any number of dimensions."
msgstr "La clase base de todas las transformaciones afines de cualquier número de dimensiones."

#: matplotlib.transforms.AffineBase.__array__:2
#: matplotlib.transforms.Transform.__array__:2 of
msgid "Array interface to get at this Transform's affine matrix."
msgstr "Interfaz de arreglo para obtener la matriz afín de esta Transformación."

#: matplotlib.transforms.AffineBase.__eq__:2
#: matplotlib.transforms.CompositeGenericTransform.__eq__:2
#: matplotlib.transforms.TransformWrapper.__eq__:2 of
msgid "Return self==value."
msgstr "Devuelve self==value."

#: matplotlib.transforms.AffineBase.get_affine:2
#: matplotlib.transforms.BlendedGenericTransform.get_affine:2
#: matplotlib.transforms.CompositeGenericTransform.get_affine:2
#: matplotlib.transforms.IdentityTransform.get_affine:2
#: matplotlib.transforms.Transform.get_affine:2 of
msgid "Get the affine part of this transform."
msgstr "Obtener la parte afín de esta transformación."

#: matplotlib.transforms.AffineBase.transform:2
#: matplotlib.transforms.IdentityTransform.transform:2
#: matplotlib.transforms.Transform.transform:2 of
msgid "Apply this transformation on the given array of *values*."
msgstr "Aplicar esta transformación sobre el arreglo de *valores* dado."

#: matplotlib.transforms.AffineBase.transform_non_affine:2
#: matplotlib.transforms.BlendedGenericTransform.transform_non_affine:2
#: matplotlib.transforms.CompositeGenericTransform.transform_non_affine:2
#: matplotlib.transforms.IdentityTransform.transform_non_affine:2
#: matplotlib.transforms.Transform.transform_non_affine:2 of
msgid "Apply only the non-affine part of this transformation."
msgstr "Aplicar sólo la parte no afín de esta transformación."

#: matplotlib.transforms.AffineBase.transform_non_affine:7
#: matplotlib.transforms.BlendedGenericTransform.transform_non_affine:7
#: matplotlib.transforms.CompositeGenericTransform.transform_non_affine:7
#: matplotlib.transforms.IdentityTransform.transform_non_affine:7
#: matplotlib.transforms.Transform.transform_non_affine:7 of
msgid "In non-affine transformations, this is generally equivalent to ``transform(values)``.  In affine transformations, this is always a no-op."
msgstr "En las transformaciones no afines, esto es generalmente equivalente a ``transformar(valores)``.  En las transformaciones afines, esto es siempre un no-op."

#: matplotlib.transforms.AffineBase.transform_path:2
#: matplotlib.transforms.IdentityTransform.transform_path:2
#: matplotlib.transforms.Transform.transform_path:2 of
msgid "Apply the transform to `.Path` *path*, returning a new `.Path`."
msgstr "Aplica la transformación a `.Path` *ruta*, devolviendo una nueva `.Path`."

#: matplotlib.transforms.AffineBase.transform_path:4
#: matplotlib.transforms.IdentityTransform.transform_path:4
#: matplotlib.transforms.Transform.transform_path:4 of
msgid "In some cases, this transform may insert curves into the path that began as line segments."
msgstr "En algunos casos, esta transformación puede insertar curvas en la trayectoria que comenzó como segmentos de línea."

#: matplotlib.transforms.AffineBase.transform_path_affine:2
#: matplotlib.transforms.IdentityTransform.transform_path_affine:2
#: matplotlib.transforms.Transform.transform_path_affine:2 of
msgid "Apply the affine part of this transform to `.Path` *path*, returning a new `.Path`."
msgstr "Aplica la parte afín de esta transformación a `.Path` *path*, devolviendo un nuevo `.Path`."

#: matplotlib.transforms.AffineBase.transform_path_affine:5
#: matplotlib.transforms.AffineBase.transform_path_non_affine:5
#: matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine:5
#: matplotlib.transforms.IdentityTransform.transform_path_affine:5
#: matplotlib.transforms.IdentityTransform.transform_path_non_affine:5
#: matplotlib.transforms.Transform.transform_path_affine:5
#: matplotlib.transforms.Transform.transform_path_non_affine:5 of
msgid "``transform_path(path)`` is equivalent to ``transform_path_affine(transform_path_non_affine(values))``."
msgstr "``transform_path(path)`` es equivalente a ``transform_path_affine(transform_path_non_affine(values))``."

#: matplotlib.transforms.AffineBase.transform_path_non_affine:2
#: matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine:2
#: matplotlib.transforms.IdentityTransform.transform_path_non_affine:2
#: matplotlib.transforms.Transform.transform_path_non_affine:2 of
msgid "Apply the non-affine part of this transform to `.Path` *path*, returning a new `.Path`."
msgstr "Aplica la parte no afín de esta transformación a `.Path` *ruta*, devolviendo una nueva `.Path`."

#: matplotlib.transforms.AffineDeltaTransform:2 of
msgid "A transform wrapper for transforming displacements between pairs of points."
msgstr "Una envoltura de transformación para transformar los desplazamientos entre pares de puntos."

#: matplotlib.transforms.AffineDeltaTransform:4 of
msgid "This class is intended to be used to transform displacements (\"position deltas\") between pairs of points (e.g., as the ``offset_transform`` of `.Collection`\\s): given a transform ``t`` such that ``t = AffineDeltaTransform(t) + offset``, ``AffineDeltaTransform`` satisfies ``AffineDeltaTransform(a - b) == AffineDeltaTransform(a) - AffineDeltaTransform(b)``."
msgstr "Esta clase está pensada para transformar desplazamientos (\"deltas de posición\") entre pares de puntos (por ejemplo, como la ``transformación de desplazamiento`` de `.Collection`s): dada una transformación ``t`` tal que ``t = AffineDeltaTransform(t) + desplazamiento``, ``AffineDeltaTransform`` satisface ``AffineDeltaTransform(a - b) == AffineDeltaTransform(a) - AffineDeltaTransform(b)``."

#: matplotlib.transforms.AffineDeltaTransform:11 of
msgid "This is implemented by forcing the offset components of the transform matrix to zero."
msgstr "Esto se implementa forzando los componentes de desplazamiento de la matriz de transformación a cero."

#: matplotlib.transforms.AffineDeltaTransform:14 of
msgid "This class is experimental as of 3.3, and the API may change."
msgstr "Esta clase es experimental a partir de la versión 3.3, y la API puede cambiar."

#: matplotlib.transforms.AffineDeltaTransform.get_matrix:2
#: matplotlib.transforms.BboxTransform.get_matrix:2
#: matplotlib.transforms.BboxTransformFrom.get_matrix:2
#: matplotlib.transforms.BboxTransformTo.get_matrix:2
#: matplotlib.transforms.BboxTransformToMaxOnly.get_matrix:2
#: matplotlib.transforms.BlendedAffine2D.get_matrix:2
#: matplotlib.transforms.CompositeAffine2D.get_matrix:2
#: matplotlib.transforms.IdentityTransform.get_matrix:2
#: matplotlib.transforms.ScaledTranslation.get_matrix:2
#: matplotlib.transforms.Transform.get_matrix:2 of
msgid "Get the matrix for the affine part of this transform."
msgstr "Obtiene la matriz para la parte afín de esta transformación."

#: matplotlib.transforms.Bbox:1 matplotlib.transforms.LockableBbox:1
#: matplotlib.transforms.TransformedBbox:1 of
msgid "Bases: :py:class:`matplotlib.transforms.BboxBase`"
msgstr "Bases: :py:class:`matplotlib.transforms.BboxBase`"

#: matplotlib.transforms.Bbox:2 of
msgid "A mutable bounding box."
msgstr "Un bounding box mutable."

#: matplotlib.transforms.Bbox:17 of
msgid "Examples"
msgstr "Ejemplos"

#: matplotlib.transforms.Bbox:18 of
msgid "**Create from known bounds**"
msgstr "**Crear a partir de límites conocidos**"

#: matplotlib.transforms.Bbox:20 of
msgid "The default constructor takes the boundary \"points\" ``[[xmin, ymin], [xmax, ymax]]``."
msgstr "El constructor por defecto toma los \"puntos\" de los límites ``[[xmin, ymin], [xmax, ymax]]``."

#: matplotlib.transforms.Bbox:26 of
msgid "Alternatively, a Bbox can be created from the flattened points array, the so-called \"extents\" ``(xmin, ymin, xmax, ymax)``"
msgstr "Alternativamente, se puede crear una Bbox a partir de la matriz de puntos aplanada, los llamados \"extents\" ``(xmin, ymin, xmax, ymax)``"

#: matplotlib.transforms.Bbox:32 of
msgid "or from the \"bounds\" ``(xmin, ymin, width, height)``."
msgstr "o de los \"bounds\" ``(xmin, ymin, width, height)``."

#: matplotlib.transforms.Bbox:37 of
msgid "**Create from collections of points**"
msgstr "**Crear a partir de colecciones de puntos**"

#: matplotlib.transforms.Bbox:39 of
msgid "The \"empty\" object for accumulating Bboxs is the null bbox, which is a stand-in for the empty set."
msgstr "El objeto \"vacío\" para acumular Bboxs es el bbox nulo, que es un sustituto del conjunto vacío."

#: matplotlib.transforms.Bbox:45 of
msgid "Adding points to the null bbox will give you the bbox of those points."
msgstr "Añadiendo puntos a la bbox nula se obtiene la bbox de esos puntos."

#: matplotlib.transforms.Bbox:55 of
msgid "Setting ``ignore=True`` is equivalent to starting over from a null bbox."
msgstr "Establecer ``ignore=True`` es equivalente a empezar de nuevo desde una bbox nula."

#: matplotlib.transforms.Bbox:63 of
msgid "It is recommended to always specify ``ignore`` explicitly.  If not, the default value of ``ignore`` can be changed at any time by code with access to your Bbox, for example using the method `~.Bbox.ignore`."
msgstr "Se recomienda especificar siempre ``ignore`` explícitamente.  De lo contrario, el valor por defecto de ``ignore`` puede ser cambiado en cualquier momento por código con acceso a su Bbox, por ejemplo usando el método."

#: matplotlib.transforms.Bbox:67 of
msgid "**Properties of the ``null`` bbox**"
msgstr "**Propiedades de la bbox ``nula`` **"

#: matplotlib.transforms.Bbox:71 of
msgid "The current behavior of `Bbox.null()` may be surprising as it does not have all of the properties of the \"empty set\", and as such does not behave like a \"zero\" object in the mathematical sense. We may change that in the future (with a deprecation period)."
msgstr "El comportamiento actual de `Bbox.null()` puede ser sorprendente ya que no tiene todas las propiedades del \"conjunto vacío\", y como tal no se comporta como un objeto \"cero\" en el sentido matemático. Puede que cambiemos esto en el futuro (con un periodo de depreciación)."

#: matplotlib.transforms.Bbox:76 of
msgid "The null bbox is the identity for intersections"
msgstr "La bbox nula es la identidad para las intersecciones"

#: matplotlib.transforms.Bbox:81 of
msgid "except with itself, where it returns the full space."
msgstr "excepto consigo mismo, donde devuelve el espacio completo."

#: matplotlib.transforms.Bbox:86 of
msgid "A union containing null will always return the full space (not the other set!)"
msgstr "Una unión que contenga null siempre devolverá el espacio completo (¡no el otro conjunto!)"

#: matplotlib.transforms.Bbox:117 matplotlib.transforms.Bbox.__init__:21 of
msgid "**points**"
msgstr "**puntos**"

#: of
msgid "ndarray"
msgstr "ndarray"

#: matplotlib.transforms.Bbox:104 matplotlib.transforms.Bbox.__init__:8 of
msgid "A 2x2 numpy array of the form ``[[x0, y0], [x1, y1]]``."
msgstr "Una matriz numpy 2x2 de la forma ``[[x0, y0], [x1, y1]]``."

#: matplotlib.transforms.Bbox.__format__:2 of
msgid "Default object formatter."
msgstr "Formateador de objetos por defecto."

#: matplotlib.transforms.Bbox.__repr__:2 of
msgid "Return repr(self)."
msgstr "Devuelve repr(self)."

#: matplotlib.transforms.Bbox.bounds:2 matplotlib.transforms.BboxBase.bounds:2
#: of
msgid "Return (:attr:`x0`, :attr:`y0`, :attr:`width`, :attr:`height`)."
msgstr "Devuelve (:attr:`x0`, :attr:`y0`, :attr:`width`, :attr:`height`)."

#: matplotlib.transforms.Bbox.from_bounds:2 of
msgid "Create a new `Bbox` from *x0*, *y0*, *width* and *height*."
msgstr "Crea una nueva `Bbox` a partir de *x0*, *y0*, *width* y *height*."

#: matplotlib.transforms.Bbox.from_bounds:4 of
msgid "*width* and *height* may be negative."
msgstr "*width* y *height* pueden ser negativos."

#: matplotlib.transforms.Bbox.from_extents:2 of
msgid "Create a new Bbox from *left*, *bottom*, *right* and *top*."
msgstr "Crea una nueva Bbox a partir de *izquierda*, *inferior*, *derecha* y *superior*."

#: matplotlib.transforms.Bbox.from_extents:4 of
msgid "The *y*-axis increases upwards."
msgstr "El eje *y* aumenta hacia arriba."

#: matplotlib.transforms.Bbox.from_extents:9 of
msgid "**left, bottom, right, top**"
msgstr "**izquierda, abajo, derecha, arriba**"

#: of
msgid "float"
msgstr "float"

#: matplotlib.transforms.Bbox.from_extents:9 of
msgid "The four extents of the bounding box."
msgstr "Las cuatro extensiones de la caja delimitadora."

#: matplotlib.transforms.Bbox.from_extents:27 of
msgid "**minpos**"
msgstr "**minpos**"

#: of
msgid "float or None"
msgstr "float o None"

#: matplotlib.transforms.Bbox.from_extents:12 of
msgid "If this is supplied, the Bbox will have a minimum positive value set. This is useful when dealing with logarithmic scales and other scales where negative bounds result in floating point errors."
msgstr "Si se suministra esto, la Bbox tendrá un valor mínimo positivo establecido. Esto es útil cuando se trata de escalas logarítmicas y otras escalas donde los límites negativos resultan en errores de punto flotante."

#: matplotlib.transforms.Bbox.frozen:2 matplotlib.transforms.BboxBase.frozen:2
#: matplotlib.transforms.TransformNode:2 of
msgid "The base class for anything that participates in the transform tree and needs to invalidate its parents or be invalidated.  This includes classes that are not really transforms, such as bounding boxes, since some transforms depend on bounding boxes to compute their values."
msgstr "La clase base para cualquier cosa que participe en el árbol de transformaciones y necesite invalidar a sus padres o ser invalidado.  Esto incluye clases que no son realmente transformaciones, como las cajas delimitadoras, ya que algunas transformaciones dependen de las cajas delimitadoras para calcular sus valores."

#: matplotlib.transforms.Bbox.get_points:2 of
msgid "Get the points of the bounding box directly as a numpy array of the form: ``[[x0, y0], [x1, y1]]``."
msgstr "Obtener los puntos de la caja delimitadora directamente como un array numpy de la forma ``[[x0, y0], [x1, y1]]``."

#: matplotlib.transforms.Bbox.ignore:2 of
msgid "Set whether the existing bounds of the box should be ignored by subsequent calls to :meth:`update_from_data_xy`."
msgstr "Establece si los límites existentes de la caja deben ser ignorados por posteriores llamadas a :meth:`update_from_data_xy`."

#: matplotlib.transforms.Bbox.ignore:24 of
msgid "value"
msgstr "valor"

#: matplotlib.transforms.interval_contains:28
#: matplotlib.transforms.interval_contains_open:28 of
msgid "bool"
msgstr "bool"

#: matplotlib.transforms.Bbox.ignore:6 of
msgid "When ``True``, subsequent calls to :meth:`update_from_data_xy` will ignore the existing bounds of the `Bbox`."
msgstr "Cuando ``True``, las llamadas posteriores a :meth:`update_from_data_xy` ignorarán los límites existentes de la `Bbox`."

#: matplotlib.transforms.Bbox.ignore:9 of
msgid "When ``False``, subsequent calls to :meth:`update_from_data_xy` will include the existing bounds of the `Bbox`."
msgstr "Cuando ``False``, las siguientes llamadas a :meth:`update_from_data_xy` incluirán los límites existentes de la `Bbox`."

#: matplotlib.transforms.Bbox.intervalx:2
#: matplotlib.transforms.BboxBase.intervalx:2 of
msgid "The pair of *x* coordinates that define the bounding box."
msgstr "El par de coordenadas *x* que definen la caja delimitadora."

#: matplotlib.transforms.Bbox.intervalx:4
#: matplotlib.transforms.BboxBase.intervalx:4 of
msgid "This is not guaranteed to be sorted from left to right."
msgstr "No se garantiza la ordenación de izquierda a derecha."

#: matplotlib.transforms.Bbox.intervaly:2
#: matplotlib.transforms.BboxBase.intervaly:2 of
msgid "The pair of *y* coordinates that define the bounding box."
msgstr "El par de coordenadas *y* que definen la caja delimitadora."

#: matplotlib.transforms.Bbox.intervaly:4
#: matplotlib.transforms.BboxBase.intervaly:4 of
msgid "This is not guaranteed to be sorted from bottom to top."
msgstr "No se garantiza la ordenación de abajo a arriba."

#: matplotlib.transforms.Bbox.minpos:2 of
msgid "The minimum positive value in both directions within the Bbox."
msgstr "El mínimo valor positivo en ambas direcciones dentro de la Bbox."

#: matplotlib.transforms.Bbox.minpos:4 of
msgid "This is useful when dealing with logarithmic scales and other scales where negative bounds result in floating point errors, and will be used as the minimum extent instead of *p0*."
msgstr "Esto es útil cuando se trata de escalas logarítmicas y otras escalas donde los límites negativos dan lugar a errores de punto flotante, y se utilizará como la extensión mínima en lugar de *p0*."

#: matplotlib.transforms.Bbox.minposx:2 of
msgid "The minimum positive value in the *x*-direction within the Bbox."
msgstr "El valor positivo mínimo en la dirección *x* dentro de la Bbox."

#: matplotlib.transforms.Bbox.minposx:4 of
msgid "This is useful when dealing with logarithmic scales and other scales where negative bounds result in floating point errors, and will be used as the minimum *x*-extent instead of *x0*."
msgstr "Esto es útil cuando se trata de escalas logarítmicas y otras escalas donde los límites negativos dan lugar a errores de punto flotante, y se utilizará como el mínimo *x*-extensión en lugar de *x0*."

#: matplotlib.transforms.Bbox.minposy:2 of
msgid "The minimum positive value in the *y*-direction within the Bbox."
msgstr "El valor positivo mínimo en la dirección *y* dentro de la Bbox."

#: matplotlib.transforms.Bbox.minposy:4 of
msgid "This is useful when dealing with logarithmic scales and other scales where negative bounds result in floating point errors, and will be used as the minimum *y*-extent instead of *y0*."
msgstr "Esto es útil cuando se trata de escalas logarítmicas y otras escalas donde los límites negativos dan lugar a errores de punto flotante, y se utilizará como el mínimo *y*-extensión en lugar de *y0*."

#: matplotlib.transforms.Bbox.mutated:2 of
msgid "Return whether the bbox has changed since init."
msgstr "Devuelve si la bbox ha cambiado desde init."

#: matplotlib.transforms.Bbox.mutatedx:2 of
msgid "Return whether the x-limits have changed since init."
msgstr "Devuelve si los límites x han cambiado desde init."

#: matplotlib.transforms.Bbox.mutatedy:2 of
msgid "Return whether the y-limits have changed since init."
msgstr "Devuelve si los límites Y han cambiado desde init."

#: matplotlib.transforms.Bbox.null:2 of
msgid "Create a new null `Bbox` from (inf, inf) to (-inf, -inf)."
msgstr "Crea una nueva `Bbox` nula desde (inf, inf) hasta (-inf, -inf)."

#: matplotlib.transforms.Bbox.p0:2 matplotlib.transforms.BboxBase.p0:2 of
msgid "The first pair of (*x*, *y*) coordinates that define the bounding box."
msgstr "El primer par de coordenadas (*x*, *y*) que definen la caja delimitadora."

#: matplotlib.transforms.Bbox.p0:4 matplotlib.transforms.BboxBase.p0:4 of
msgid "This is not guaranteed to be the bottom-left corner (for that, use :attr:`min`)."
msgstr "No se garantiza que sea la esquina inferior izquierda (para ello, utilice :attr:`min`)."

#: matplotlib.transforms.Bbox.p1:2 matplotlib.transforms.BboxBase.p1:2 of
msgid "The second pair of (*x*, *y*) coordinates that define the bounding box."
msgstr "El segundo par de coordenadas (*x*, *y*) que definen la caja delimitadora."

#: matplotlib.transforms.Bbox.p1:4 matplotlib.transforms.BboxBase.p1:4 of
msgid "This is not guaranteed to be the top-right corner (for that, use :attr:`max`)."
msgstr "No se garantiza que sea la esquina superior derecha (para ello, utilice :attr:`max`)."

#: matplotlib.transforms.Bbox.set:2 of
msgid "Set this bounding box from the \"frozen\" bounds of another `Bbox`."
msgstr "Establece esta caja delimitadora a partir de los límites \"congelados\" de otra `Bbox`."

#: matplotlib.transforms.Bbox.set_points:2 of
msgid "Set the points of the bounding box directly from a numpy array of the form: ``[[x0, y0], [x1, y1]]``.  No error checking is performed, as this method is mainly for internal use."
msgstr "Establece los puntos de la caja delimitadora directamente desde un array de numpy de la forma ``[[x0, y0], [x1, y1]]``.  No se realiza ninguna comprobación de errores, ya que este método es principalmente de uso interno."

#: matplotlib.transforms.Bbox.unit:2 of
msgid "Create a new unit `Bbox` from (0, 0) to (1, 1)."
msgstr "Crea una nueva `Bbox` unitaria desde (0, 0) hasta (1, 1)."

#: matplotlib.transforms.Bbox.update_from_data_x:2 of
msgid "Update the x-bounds of the `Bbox` based on the passed in data. After updating, the bounds will have positive *width*, and *x0* will be the minimal value."
msgstr "Actualiza los límites x de la `Bbox` basándose en los datos pasados. Después de la actualización, los límites tendrán *ancho* positivo, y *x0* será el valor mínimo."

#: matplotlib.transforms.Bbox.update_from_data_x:10 of
msgid "**x**"
msgstr "**x**"

#: matplotlib.transforms.Bbox.update_from_data_x:10 of
msgid "Array of x-values."
msgstr "Matriz de valores x."

#: matplotlib.transforms.Bbox.update_from_data_x:28
#: matplotlib.transforms.Bbox.update_from_data_xy:15
#: matplotlib.transforms.Bbox.update_from_data_y:28
#: matplotlib.transforms.Bbox.update_from_path:15 of
msgid "**ignore**"
msgstr "**ignorar**"

#: of
msgid "bool, optional"
msgstr "bool, opcional"

#: matplotlib.transforms.Bbox.update_from_data_x:13
#: matplotlib.transforms.Bbox.update_from_data_xy:13
#: matplotlib.transforms.Bbox.update_from_data_y:13 of
msgid "When ``True``, ignore the existing bounds of the `Bbox`."
msgstr "Cuando ``False``, incluye los límites existentes de la `Bbox`."

#: matplotlib.transforms.Bbox.update_from_data_x:14
#: matplotlib.transforms.Bbox.update_from_data_xy:14
#: matplotlib.transforms.Bbox.update_from_data_y:14 of
msgid "When ``False``, include the existing bounds of the `Bbox`."
msgstr "Cuando ``False``, incluye los límites existentes de la `Bbox`."

#: matplotlib.transforms.Bbox.update_from_data_x:15
#: matplotlib.transforms.Bbox.update_from_data_xy:15
#: matplotlib.transforms.Bbox.update_from_data_y:15 of
msgid "When ``None``, use the last value passed to :meth:`ignore`."
msgstr "Cuando ``None``, utiliza el último valor pasado a :meth:`ignore`."

#: matplotlib.transforms.Bbox.update_from_data_xy:2 of
msgid "Update the bounds of the `Bbox` based on the passed in data. After updating, the bounds will have positive *width* and *height*; *x0* and *y0* will be the minimal values."
msgstr "Actualiza los límites de la `Bbox` basándose en los datos pasados. Después de la actualización, los límites tendrán *ancho* y *altura* positivos; *x0* e *y0* serán los valores mínimos."

#: matplotlib.transforms.Bbox.update_from_data_xy:10 of
msgid "**xy**"
msgstr "**xy**"

#: matplotlib.transforms.Bbox.update_from_data_xy:10 of
msgid "A numpy array of 2D points."
msgstr "Una matriz numpy de puntos 2D."

#: matplotlib.transforms.Bbox.update_from_data_xy:31
#: matplotlib.transforms.Bbox.update_from_path:31 of
msgid "**updatex, updatey**"
msgstr "**updatex, updatey**"

#: of
msgid "bool, default: True"
msgstr "bool, por defecto: True"

#: matplotlib.transforms.Bbox.update_from_data_xy:18
#: matplotlib.transforms.Bbox.update_from_path:18 of
msgid "When ``True``, update the x/y values."
msgstr "Cuando ``True``, actualiza los valores x/y."

#: matplotlib.transforms.Bbox.update_from_data_y:2 of
msgid "Update the y-bounds of the `Bbox` based on the passed in data. After updating, the bounds will have positive *height*, and *y0* will be the minimal value."
msgstr "Actualiza los límites Y de la `Bbox` basándose en los datos pasados. Después de la actualización, los límites tendrán *altura* positiva, y *y0* será el valor mínimo."

#: matplotlib.transforms.Bbox.update_from_data_y:10 of
msgid "**y**"
msgstr "**y**"

#: matplotlib.transforms.Bbox.update_from_data_y:10 of
msgid "Array of y-values."
msgstr "Matriz de valores y."

#: matplotlib.transforms.Bbox.update_from_path:2 of
msgid "Update the bounds of the `Bbox` to contain the vertices of the provided path. After updating, the bounds will have positive *width* and *height*; *x0* and *y0* will be the minimal values."
msgstr "Actualiza los límites de la `Bbox` para que contenga los vértices del camino proporcionado. Tras la actualización, los límites tendrán *ancho* y *alto* positivos; *x0* e *y0* serán los valores mínimos."

#: matplotlib.transforms.Bbox.update_from_path:10 of
msgid "**path** : `~matplotlib.path.Path`"
msgstr "**path** : `~matplotlib.path.Path`"

#: matplotlib.transforms.Bbox.update_from_path:9
#: matplotlib.transforms.TransformedPath:34
#: matplotlib.transforms.TransformedPath.__init__:7 of
msgid "Path"
msgstr "Ruta"

#: matplotlib.transforms.Bbox.update_from_path:13 of
msgid "when ``True``, ignore the existing bounds of the `Bbox`."
msgstr "cuando es ``True``, ignorar los límites existentes de la `Bbox`."

#: matplotlib.transforms.Bbox.update_from_path:14 of
msgid "when ``False``, include the existing bounds of the `Bbox`."
msgstr "cuando es ``False``, incluir los límites existentes de la `Bbox`."

#: matplotlib.transforms.Bbox.update_from_path:15 of
msgid "when ``None``, use the last value passed to :meth:`ignore`."
msgstr "cuando ``None``, usar el último valor pasado a :meth:`ignore`."

#: matplotlib.transforms.Bbox.x0:2 matplotlib.transforms.BboxBase.x0:2 of
msgid "The first of the pair of *x* coordinates that define the bounding box."
msgstr "La primera del par de coordenadas *x* que definen la caja delimitadora."

#: matplotlib.transforms.Bbox.x0:4 matplotlib.transforms.BboxBase.x0:4 of
msgid "This is not guaranteed to be less than :attr:`x1` (for that, use :attr:`xmin`)."
msgstr "No se garantiza que sea menor que :attr:`x1` (para ello, utilice :attr:`xmin`)."

#: matplotlib.transforms.Bbox.x1:2 matplotlib.transforms.BboxBase.x1:2 of
msgid "The second of the pair of *x* coordinates that define the bounding box."
msgstr "La segunda del par de coordenadas *x* que definen la caja delimitadora."

#: matplotlib.transforms.Bbox.x1:4 matplotlib.transforms.BboxBase.x1:4 of
msgid "This is not guaranteed to be greater than :attr:`x0` (for that, use :attr:`xmax`)."
msgstr "No se garantiza que sea mayor que :attr:`x0` (para ello, utilice :attr:`xmax`)."

#: matplotlib.transforms.Bbox.y0:2 matplotlib.transforms.BboxBase.y0:2 of
msgid "The first of the pair of *y* coordinates that define the bounding box."
msgstr "La primera del par de coordenadas *y* que definen la caja delimitadora."

#: matplotlib.transforms.Bbox.y0:4 matplotlib.transforms.BboxBase.y0:4 of
msgid "This is not guaranteed to be less than :attr:`y1` (for that, use :attr:`ymin`)."
msgstr "No se garantiza que sea menor que :attr:`y1` (para ello, utilice :attr:`ymin`)."

#: matplotlib.transforms.Bbox.y1:2 matplotlib.transforms.BboxBase.y1:2 of
msgid "The second of the pair of *y* coordinates that define the bounding box."
msgstr ""

#: matplotlib.transforms.Bbox.y1:4 matplotlib.transforms.BboxBase.y1:4 of
msgid "This is not guaranteed to be greater than :attr:`y0` (for that, use :attr:`ymax`)."
msgstr ""

#: matplotlib.transforms.BboxBase:1 matplotlib.transforms.Transform:1
#: matplotlib.transforms.TransformedPath:1 of
msgid "Bases: :py:class:`matplotlib.transforms.TransformNode`"
msgstr ""

#: matplotlib.transforms.BboxBase:2 of
msgid "The base class of all bounding boxes."
msgstr ""

#: matplotlib.transforms.BboxBase:4 of
msgid "This class is immutable; `Bbox` is a mutable subclass."
msgstr ""

#: matplotlib.transforms.BboxBase:6 of
msgid "The canonical representation is as two points, with no restrictions on their ordering.  Convenience properties are provided to get the left, bottom, right and top edges and width and height, but these are not stored explicitly."
msgstr ""

#: matplotlib.transforms.BboxBase.anchored:2 of
msgid "Return a copy of the `Bbox` anchored to *c* within *container*."
msgstr ""

#: matplotlib.transforms.BboxBase.anchored:10 of
msgid "**c**"
msgstr ""

#: of
msgid "(float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}"
msgstr ""

#: matplotlib.transforms.BboxBase.anchored:8 of
msgid "Either an (*x*, *y*) pair of relative coordinates (0 is left or bottom, 1 is right or top), 'C' (center), or a cardinal direction ('SW', southwest, is bottom left, etc.)."
msgstr ""

#: matplotlib.transforms.BboxBase.anchored:21 of
msgid "**container** : `Bbox`, optional"
msgstr ""

#: matplotlib.transforms.BboxBase.anchored:20 of
msgid "Bbox, optional"
msgstr ""

#: matplotlib.transforms.BboxBase.anchored:13 of
msgid "The box within which the `Bbox` is positioned; it defaults to the initial `Bbox`."
msgstr ""

#: matplotlib.transforms.BboxBase.anchored:26 of
msgid ":obj:`.Axes.set_anchor`"
msgstr ""

#: matplotlib.transforms.BboxBase.contains:2 of
msgid "Return whether ``(x, y)`` is in the bounding box or on its edge."
msgstr ""

#: matplotlib.transforms.BboxBase.containsx:2 of
msgid "Return whether *x* is in the closed (:attr:`x0`, :attr:`x1`) interval."
msgstr ""

#: matplotlib.transforms.BboxBase.containsy:2 of
msgid "Return whether *y* is in the closed (:attr:`y0`, :attr:`y1`) interval."
msgstr ""

#: matplotlib.transforms.BboxBase.corners:2 of
msgid "Return the corners of this rectangle as an array of points."
msgstr ""

#: matplotlib.transforms.BboxBase.corners:4 of
msgid "Specifically, this returns the array ``[[x0, y0], [x0, y1], [x1, y0], [x1, y1]]``."
msgstr ""

#: matplotlib.transforms.BboxBase.count_contains:2 of
msgid "Count the number of vertices contained in the `Bbox`. Any vertices with a non-finite x or y value are ignored."
msgstr ""

#: matplotlib.transforms.BboxBase.count_contains:22 of
msgid "**vertices**"
msgstr ""

#: of
msgid "Nx2 Numpy array."
msgstr ""

#: matplotlib.transforms.BboxBase.count_overlaps:2 of
msgid "Count the number of bounding boxes that overlap this one."
msgstr ""

#: matplotlib.transforms.BboxBase.count_overlaps:21 of
msgid "**bboxes** : sequence of `.BboxBase`"
msgstr ""

#: of
msgid "sequence of"
msgstr ""

#: matplotlib.transforms.BboxBase.expanded:2 of
msgid "Construct a `Bbox` by expanding this one around its center by the factors *sw* and *sh*."
msgstr ""

#: matplotlib.transforms.BboxBase.extents:2 of
msgid "Return (:attr:`x0`, :attr:`y0`, :attr:`x1`, :attr:`y1`)."
msgstr ""

#: matplotlib.transforms.BboxBase.fully_contains:2 of
msgid "Return whether ``x, y`` is in the bounding box, but not on its edge."
msgstr ""

#: matplotlib.transforms.BboxBase.fully_containsx:2 of
msgid "Return whether *x* is in the open (:attr:`x0`, :attr:`x1`) interval."
msgstr ""

#: matplotlib.transforms.BboxBase.fully_containsy:2 of
msgid "Return whether *y* is in the open (:attr:`y0`, :attr:`y1`) interval."
msgstr ""

#: matplotlib.transforms.BboxBase.fully_overlaps:2 of
msgid "Return whether this bounding box overlaps with the other bounding box, not including the edges."
msgstr ""

#: matplotlib.transforms.BboxBase.fully_overlaps:22
#: matplotlib.transforms.BboxBase.overlaps:21 of
msgid "**other** : `.BboxBase`"
msgstr ""

#: matplotlib.transforms.BboxBase.fully_overlaps:21
#: matplotlib.transforms.BboxBase.overlaps:20 of
msgid "BboxBase"
msgstr ""

#: matplotlib.transforms.BboxBase.height:2 of
msgid "The (signed) height of the bounding box."
msgstr ""

#: matplotlib.transforms.BboxBase.intersection:2 of
msgid "Return the intersection of *bbox1* and *bbox2* if they intersect, or None if they don't."
msgstr ""

#: matplotlib.transforms.BboxBase.max:2 of
msgid "The top-right corner of the bounding box."
msgstr ""

#: matplotlib.transforms.BboxBase.min:2 of
msgid "The bottom-left corner of the bounding box."
msgstr ""

#: matplotlib.transforms.BboxBase.overlaps:2 of
msgid "Return whether this bounding box overlaps with the other bounding box."
msgstr ""

#: matplotlib.transforms.BboxBase.padded:2 of
msgid "Construct a `Bbox` by padding this one on all four sides by *p*."
msgstr ""

#: matplotlib.transforms.BboxBase.rotated:2 of
msgid "Return the axes-aligned bounding box that bounds the result of rotating this `Bbox` by an angle of *radians*."
msgstr ""

#: matplotlib.transforms.BboxBase.shrunk:2 of
msgid "Return a copy of the `Bbox`, shrunk by the factor *mx* in the *x* direction and the factor *my* in the *y* direction. The lower left corner of the box remains unchanged.  Normally *mx* and *my* will be less than 1, but this is not enforced."
msgstr ""

#: matplotlib.transforms.BboxBase.shrunk_to_aspect:2 of
msgid "Return a copy of the `Bbox`, shrunk so that it is as large as it can be while having the desired aspect ratio, *box_aspect*.  If the box coordinates are relative (i.e. fractions of a larger box such as a figure) then the physical aspect ratio of that figure is specified with *fig_aspect*, so that *box_aspect* can also be given as a ratio of the absolute dimensions, not the relative dimensions."
msgstr ""

#: matplotlib.transforms.BboxBase.size:2 of
msgid "The (signed) width and height of the bounding box."
msgstr ""

#: matplotlib.transforms.BboxBase.splitx:2 of
msgid "Return a list of new `Bbox` objects formed by splitting the original one with vertical lines at fractional positions given by *args*."
msgstr ""

#: matplotlib.transforms.BboxBase.splity:2 of
msgid "Return a list of new `Bbox` objects formed by splitting the original one with horizontal lines at fractional positions given by *args*."
msgstr ""

#: matplotlib.transforms.BboxBase.transformed:2 of
msgid "Construct a `Bbox` by statically transforming this one by *transform*."
msgstr ""

#: matplotlib.transforms.BboxBase.translated:2 of
msgid "Construct a `Bbox` by translating this one by *tx* and *ty*."
msgstr ""

#: matplotlib.transforms.BboxBase.union:2 of
msgid "Return a `Bbox` that contains all of the given *bboxes*."
msgstr ""

#: matplotlib.transforms.BboxBase.width:2 of
msgid "The (signed) width of the bounding box."
msgstr ""

#: matplotlib.transforms.BboxBase.xmax:2 of
msgid "The right edge of the bounding box."
msgstr ""

#: matplotlib.transforms.BboxBase.xmin:2 of
msgid "The left edge of the bounding box."
msgstr ""

#: matplotlib.transforms.BboxBase.ymax:2 of
msgid "The top edge of the bounding box."
msgstr ""

#: matplotlib.transforms.BboxBase.ymin:2 of
msgid "The bottom edge of the bounding box."
msgstr ""

#: matplotlib.transforms.BboxTransform:2 of
msgid "`BboxTransform` linearly transforms points from one `Bbox` to another."
msgstr ""

#: matplotlib.transforms.BboxTransform:23
#: matplotlib.transforms.BboxTransform.__init__:2 of
msgid "Create a new `BboxTransform` that linearly transforms points from *boxin* to *boxout*."
msgstr ""

#: ../../docstring matplotlib.transforms.BboxTransform.is_separable:2
#: matplotlib.transforms.BboxTransformFrom.is_separable:2
#: matplotlib.transforms.BboxTransformTo.is_separable:2
#: matplotlib.transforms.BlendedAffine2D.is_separable:2
#: matplotlib.transforms.BlendedGenericTransform.is_separable:2
#: matplotlib.transforms.Transform.is_separable:2 of
msgid "True if this transform is separable in the x- and y- dimensions."
msgstr ""

#: matplotlib.transforms.BboxTransformFrom:2 of
msgid "`BboxTransformFrom` linearly transforms points from a given `Bbox` to the unit bounding box."
msgstr ""

#: matplotlib.transforms.BboxTransformTo:2 of
msgid "`BboxTransformTo` is a transformation that linearly transforms points from the unit bounding box to a given `Bbox`."
msgstr ""

#: matplotlib.transforms.BboxTransformTo:24
#: matplotlib.transforms.BboxTransformTo.__init__:2
#: matplotlib.transforms.BboxTransformToMaxOnly:24 of
msgid "Create a new `BboxTransformTo` that linearly transforms points from the unit bounding box to *boxout*."
msgstr ""

#: matplotlib.transforms.BboxTransformToMaxOnly:1 of
msgid "Bases: :py:class:`matplotlib.transforms.BboxTransformTo`"
msgstr ""

#: matplotlib.transforms.BboxTransformToMaxOnly:2 of
msgid "`BboxTransformTo` is a transformation that linearly transforms points from the unit bounding box to a given `Bbox` with a fixed upper left of (0, 0)."
msgstr ""

#: matplotlib.transforms.BlendedAffine2D:1 of
msgid "Bases: :py:class:`matplotlib.transforms._BlendedMixin`, :py:class:`matplotlib.transforms.Affine2DBase`"
msgstr ""

#: matplotlib.transforms.BlendedAffine2D:2
#: matplotlib.transforms.BlendedGenericTransform:2 of
msgid "A \"blended\" transform uses one transform for the *x*-direction, and another transform for the *y*-direction."
msgstr ""

#: matplotlib.transforms.BlendedAffine2D:5 of
msgid "This version is an optimization for the case where both child transforms are of type `Affine2DBase`."
msgstr ""

#: matplotlib.transforms.BlendedAffine2D:26
#: matplotlib.transforms.BlendedAffine2D.__init__:2
#: matplotlib.transforms.BlendedGenericTransform:26
#: matplotlib.transforms.BlendedGenericTransform.__init__:2
#: matplotlib.transforms.blended_transform_factory:2 of
msgid "Create a new \"blended\" transform using *x_transform* to transform the *x*-axis and *y_transform* to transform the *y*-axis."
msgstr ""

#: matplotlib.transforms.BlendedAffine2D:29
#: matplotlib.transforms.BlendedAffine2D.__init__:5 of
msgid "Both *x_transform* and *y_transform* must be 2D affine transforms."
msgstr ""

#: matplotlib.transforms.BlendedAffine2D:31
#: matplotlib.transforms.BlendedAffine2D.__init__:7
#: matplotlib.transforms.BlendedGenericTransform:29
#: matplotlib.transforms.BlendedGenericTransform.__init__:5 of
msgid "You will generally not call this constructor directly but use the `blended_transform_factory` function instead, which can determine automatically which kind of blended transform to create."
msgstr ""

#: matplotlib.transforms.BlendedGenericTransform:1 of
msgid "Bases: :py:class:`matplotlib.transforms._BlendedMixin`, :py:class:`matplotlib.transforms.Transform`"
msgstr ""

#: matplotlib.transforms.BlendedGenericTransform:5 of
msgid "This \"generic\" version can handle any given child transform in the *x*- and *y*-directions."
msgstr ""

#: matplotlib.transforms.BlendedGenericTransform.contains_branch:2
#: matplotlib.transforms.Transform.contains_branch:2 of
msgid "Return whether the given transform is a sub-tree of this transform."
msgstr ""

#: matplotlib.transforms.BlendedGenericTransform.contains_branch:4
#: matplotlib.transforms.Transform.contains_branch:4 of
msgid "This routine uses transform equality to identify sub-trees, therefore in many situations it is object id which will be used."
msgstr ""

#: matplotlib.transforms.BlendedGenericTransform.contains_branch:7
#: matplotlib.transforms.Transform.contains_branch:7 of
msgid "For the case where the given transform represents the whole of this transform, returns True."
msgstr ""

#: matplotlib.transforms.BlendedGenericTransform.depth:2
#: matplotlib.transforms.CompositeAffine2D.depth:2
#: matplotlib.transforms.CompositeGenericTransform.depth:2
#: matplotlib.transforms.Transform.depth:2 of
msgid "Return the number of transforms which have been chained together to form this Transform instance."
msgstr ""

#: matplotlib.transforms.BlendedGenericTransform.depth:7
#: matplotlib.transforms.CompositeAffine2D.depth:7
#: matplotlib.transforms.CompositeGenericTransform.depth:7
#: matplotlib.transforms.Transform.depth:7 of
msgid "For the special case of a Composite transform, the maximum depth of the two is returned."
msgstr ""

#: ../../docstring matplotlib.transforms.BlendedGenericTransform.pass_through:2
#: matplotlib.transforms.CompositeGenericTransform.pass_through:2
#: matplotlib.transforms.TransformNode.pass_through:2
#: matplotlib.transforms.TransformWrapper.pass_through:2 of
msgid "If pass_through is True, all ancestors will always be invalidated, even if 'self' is already invalid."
msgstr ""

#: matplotlib.transforms.CompositeAffine2D:2
#: matplotlib.transforms.CompositeGenericTransform:2 of
msgid "A composite transform formed by applying transform *a* then transform *b*."
msgstr ""

#: matplotlib.transforms.CompositeAffine2D:4 of
msgid "This version is an optimization that handles the case where both *a* and *b* are 2D affines."
msgstr ""

#: matplotlib.transforms.CompositeAffine2D:25
#: matplotlib.transforms.CompositeAffine2D.__init__:2 of
msgid "Create a new composite transform that is the result of applying `Affine2DBase` *a* then `Affine2DBase` *b*."
msgstr ""

#: matplotlib.transforms.CompositeAffine2D:28
#: matplotlib.transforms.CompositeAffine2D.__init__:5
#: matplotlib.transforms.CompositeGenericTransform:29
#: matplotlib.transforms.CompositeGenericTransform.__init__:5 of
msgid "You will generally not call this constructor directly but write ``a + b`` instead, which will automatically choose the best kind of composite transform instance to create."
msgstr ""

#: matplotlib.transforms.CompositeGenericTransform:5 of
msgid "This \"generic\" version can handle any two arbitrary transformations."
msgstr ""

#: matplotlib.transforms.CompositeGenericTransform:26
#: matplotlib.transforms.CompositeGenericTransform.__init__:2 of
msgid "Create a new composite transform that is the result of applying transform *a* then transform *b*."
msgstr ""

#: matplotlib.transforms.IdentityTransform:2 of
msgid "A special class that does one thing, the identity transform, in a fast way."
msgstr ""

#: matplotlib.transforms.LockableBbox:2 of
msgid "A `Bbox` where some elements may be locked at certain values."
msgstr ""

#: matplotlib.transforms.LockableBbox:4 of
msgid "When the child bounding box changes, the bounds of this bbox will update accordingly with the exception of the locked elements."
msgstr ""

#: matplotlib.transforms.LockableBbox:31
#: matplotlib.transforms.LockableBbox.__init__:8
#: matplotlib.transforms.TransformedBbox:31
#: matplotlib.transforms.TransformedBbox.__init__:8 of
msgid "**bbox** : `Bbox`"
msgstr ""

#: matplotlib.transforms.LockableBbox:30
#: matplotlib.transforms.LockableBbox.__init__:7
#: matplotlib.transforms.TransformedBbox:30
#: matplotlib.transforms.TransformedBbox.__init__:7 of
msgid "Bbox"
msgstr ""

#: matplotlib.transforms.LockableBbox:31
#: matplotlib.transforms.LockableBbox.__init__:8 of
msgid "The child bounding box to wrap."
msgstr ""

#: matplotlib.transforms.LockableBbox:34
#: matplotlib.transforms.LockableBbox.__init__:11 of
msgid "**x0**"
msgstr ""

#: matplotlib.transforms.LockableBbox:34
#: matplotlib.transforms.LockableBbox.__init__:11 of
msgid "The locked value for x0, or None to leave unlocked."
msgstr ""

#: matplotlib.transforms.LockableBbox:37
#: matplotlib.transforms.LockableBbox.__init__:14 of
msgid "**y0**"
msgstr ""

#: matplotlib.transforms.LockableBbox:37
#: matplotlib.transforms.LockableBbox.__init__:14 of
msgid "The locked value for y0, or None to leave unlocked."
msgstr ""

#: matplotlib.transforms.LockableBbox:40
#: matplotlib.transforms.LockableBbox.__init__:17 of
msgid "**x1**"
msgstr ""

#: matplotlib.transforms.LockableBbox:40
#: matplotlib.transforms.LockableBbox.__init__:17 of
msgid "The locked value for x1, or None to leave unlocked."
msgstr ""

#: matplotlib.transforms.LockableBbox:56
#: matplotlib.transforms.LockableBbox.__init__:33 of
msgid "**y1**"
msgstr ""

#: matplotlib.transforms.LockableBbox:43
#: matplotlib.transforms.LockableBbox.__init__:20 of
msgid "The locked value for y1, or None to leave unlocked."
msgstr ""

#: matplotlib.transforms.LockableBbox.locked_x0:2 of
msgid "float or None: The value used for the locked x0."
msgstr ""

#: matplotlib.transforms.LockableBbox.locked_x1:2 of
msgid "float or None: The value used for the locked x1."
msgstr ""

#: matplotlib.transforms.LockableBbox.locked_y0:2 of
msgid "float or None: The value used for the locked y0."
msgstr ""

#: matplotlib.transforms.LockableBbox.locked_y1:2 of
msgid "float or None: The value used for the locked y1."
msgstr ""

#: matplotlib.transforms.ScaledTranslation:2 of
msgid "A transformation that translates by *xt* and *yt*, after *xt* and *yt* have been transformed by *scale_trans*."
msgstr ""

#: matplotlib.transforms.Transform:2 of
msgid "The base class of all `TransformNode` instances that actually perform a transformation."
msgstr ""

#: matplotlib.transforms.Transform:5 of
msgid "All non-affine transformations should be subclasses of this class. New affine transformations should be subclasses of `Affine2D`."
msgstr ""

#: matplotlib.transforms.Transform:8 of
msgid "Subclasses of this class should override the following members (at minimum):"
msgstr ""

#: matplotlib.transforms.Transform:11 of
msgid ":attr:`input_dims`"
msgstr ""

#: matplotlib.transforms.Transform:12 of
msgid ":attr:`output_dims`"
msgstr ""

#: matplotlib.transforms.Transform:13 of
msgid ":meth:`transform`"
msgstr ":meth:`transform`"

#: matplotlib.transforms.Transform:14 of
msgid ":meth:`inverted` (if an inverse exists)"
msgstr ""

#: matplotlib.transforms.Transform:16 of
msgid "The following attributes may be overridden if the default is unsuitable:"
msgstr ""

#: matplotlib.transforms.Transform:18 of
msgid ":attr:`is_separable` (defaults to True for 1D -> 1D transforms, False otherwise)"
msgstr ""

#: matplotlib.transforms.Transform:20 of
msgid ":attr:`has_inverse` (defaults to True if :meth:`inverted` is overridden, False otherwise)"
msgstr ""

#: matplotlib.transforms.Transform:23 of
msgid "If the transform needs to do something non-standard with `matplotlib.path.Path` objects, such as adding curves where there were once line segments, it should override:"
msgstr ""

#: matplotlib.transforms.Transform:27 of
msgid ":meth:`transform_path`"
msgstr ""

#: matplotlib.transforms.Transform.__add__:2 of
msgid "Compose two transforms together so that *self* is followed by *other*."
msgstr ""

#: matplotlib.transforms.Transform.__add__:4 of
msgid "``A + B`` returns a transform ``C`` so that ``C.transform(x) == B.transform(A.transform(x))``."
msgstr ""

#: matplotlib.transforms.Transform.__init_subclass__:2 of
msgid "This method is called when a class is subclassed."
msgstr ""

#: matplotlib.transforms.Transform.__init_subclass__:4 of
msgid "The default implementation does nothing. It may be overridden to extend subclasses."
msgstr ""

#: matplotlib.transforms.Transform.__sub__:2 of
msgid "Compose *self* with the inverse of *other*, cancelling identical terms if any::"
msgstr ""

#: matplotlib.transforms.Transform.__sub__:16 of
msgid "Cancellation (rather than naively returning ``A + B.inverted()``) is important for multiple reasons:"
msgstr ""

#: matplotlib.transforms.Transform.__sub__:19 of
msgid "It avoids floating-point inaccuracies when computing the inverse of B: ``B - B`` is guaranteed to cancel out exactly (resulting in the identity transform), whereas ``B + B.inverted()`` may differ by a small epsilon."
msgstr ""

#: matplotlib.transforms.Transform.__sub__:23 of
msgid "``B.inverted()`` always returns a frozen transform: if one computes ``A + B + B.inverted()`` and later mutates ``B``, then ``B.inverted()`` won't be updated and the last two terms won't cancel out anymore; on the other hand, ``A + B - B`` will always be equal to ``A`` even if ``B`` is mutated."
msgstr ""

#: matplotlib.transforms.Transform.contains_branch_seperately:2 of
msgid "Return whether the given branch is a sub-tree of this transform on each separate dimension."
msgstr ""

#: matplotlib.transforms.Transform.contains_branch_seperately:5 of
msgid "A common use for this method is to identify if a transform is a blended transform containing an axes' data transform. e.g.::"
msgstr ""

#: matplotlib.transforms.Transform.transform_angles:2 of
msgid "Transform a set of angles anchored at specific locations."
msgstr ""

#: matplotlib.transforms.Transform.transform_angles:8 of
msgid "**angles**"
msgstr ""

#: of
msgid "(N,) array-like"
msgstr ""

#: matplotlib.transforms.Transform.transform_angles:8 of
msgid "The angles to transform."
msgstr ""

#: matplotlib.transforms.Transform.transform_angles:11 of
msgid "**pts**"
msgstr ""

#: of
msgid "(N, 2) array-like"
msgstr ""

#: matplotlib.transforms.Transform.transform_angles:11 of
msgid "The points where the angles are anchored."
msgstr ""

#: matplotlib.transforms.Transform.transform_angles:14 of
msgid "**radians**"
msgstr ""

#: of
msgid "bool, default: False"
msgstr ""

#: matplotlib.transforms.Transform.transform_angles:14 of
msgid "Whether *angles* are radians or degrees."
msgstr ""

#: matplotlib.transforms.Transform.transform_angles:21 of
msgid "**pushoff**"
msgstr ""

#: matplotlib.transforms.Transform.transform_angles:17 of
msgid "For each point in *pts* and angle in *angles*, the transformed angle is computed by transforming a segment of length *pushoff* starting at that point and making that angle relative to the horizontal axis, and measuring the angle between the horizontal axis and the transformed segment."
msgstr ""

#: matplotlib.transforms.Transform.transform_angles:38 of
msgid "(N,) array"
msgstr ""

#: matplotlib.transforms.Transform.transform_bbox:2 of
msgid "Transform the given bounding box."
msgstr ""

#: matplotlib.transforms.Transform.transform_bbox:4 of
msgid "For smarter transforms including caching (a common requirement in Matplotlib), see `TransformedBbox`."
msgstr ""

#: matplotlib.transforms.Transform.transform_point:2 of
msgid "Return a transformed point."
msgstr ""

#: matplotlib.transforms.Transform.transform_point:4 of
msgid "This function is only kept for backcompatibility; the more general `.transform` method is capable of transforming both a list of points and a single point."
msgstr ""

#: matplotlib.transforms.Transform.transform_point:8 of
msgid "The point is given as a sequence of length :attr:`input_dims`. The transformed point is returned as a sequence of length :attr:`output_dims`."
msgstr ""

#: matplotlib.transforms.TransformNode:1 of
msgid "Bases: :py:class:`object`"
msgstr ""

#: ../../docstring matplotlib.transforms.TransformNode.__weakref__:2 of
msgid "list of weak references to the object (if defined)"
msgstr ""

#: matplotlib.transforms.TransformNode.invalidate:2 of
msgid "Invalidate this `TransformNode` and triggers an invalidation of its ancestors.  Should be called any time the transform changes."
msgstr ""

#: matplotlib.transforms.TransformNode.set_children:2 of
msgid "Set the children of the transform, to let the invalidation system know which transforms can invalidate this transform. Should be called from the constructor of any transforms that depend on other transforms."
msgstr ""

#: matplotlib.transforms.TransformWrapper:2 of
msgid "A helper class that holds a single child transform and acts equivalently to it."
msgstr ""

#: matplotlib.transforms.TransformWrapper:5 of
msgid "This is useful if a node of the transform tree must be replaced at run time with a transform of a different type.  This class allows that replacement to correctly trigger invalidation."
msgstr ""

#: matplotlib.transforms.TransformWrapper:9 of
msgid "`TransformWrapper` instances must have the same input and output dimensions during their entire lifetime, so the child transform may only be replaced with another child transform of the same dimensions."
msgstr ""

#: matplotlib.transforms.TransformWrapper:31
#: matplotlib.transforms.TransformWrapper.__init__:2 of
msgid "*child*: A `Transform` instance.  This child may later be replaced with :meth:`set`."
msgstr ""

#: matplotlib.transforms.TransformWrapper.set:2 of
msgid "Replace the current child of this transform with another one."
msgstr ""

#: matplotlib.transforms.TransformWrapper.set:4 of
msgid "The new child must have the same number of input and output dimensions as the current child."
msgstr ""

#: matplotlib.transforms.TransformedBbox:2 of
msgid "A `Bbox` that is automatically transformed by a given transform.  When either the child bounding box or transform changes, the bounds of this bbox will update accordingly."
msgstr ""

#: matplotlib.transforms.TransformedBbox:47
#: matplotlib.transforms.TransformedBbox.__init__:24
#: matplotlib.transforms.TransformedPath:51
#: matplotlib.transforms.TransformedPath.__init__:24 of
msgid "**transform** : `Transform`"
msgstr ""

#: matplotlib.transforms.TransformedBbox:46
#: matplotlib.transforms.TransformedBbox.__init__:23
#: matplotlib.transforms.TransformedPath:50
#: matplotlib.transforms.TransformedPath.__init__:23 of
msgid "Transform"
msgstr ""

#: matplotlib.transforms.TransformedPatchPath:1 of
msgid "Bases: :py:class:`matplotlib.transforms.TransformedPath`"
msgstr ""

#: matplotlib.transforms.TransformedPatchPath:2 of
msgid "A `TransformedPatchPath` caches a non-affine transformed copy of the `~.patches.Patch`. This cached copy is automatically updated when the non-affine part of the transform or the patch changes."
msgstr ""

#: matplotlib.transforms.TransformedPatchPath:44
#: matplotlib.transforms.TransformedPatchPath.__init__:21 of
msgid "**patch** : `~.patches.Patch`"
msgstr ""

#: matplotlib.transforms.TransformedPatchPath:43
#: matplotlib.transforms.TransformedPatchPath.__init__:20 of
msgid "Patch"
msgstr ""

#: matplotlib.transforms.TransformedPath:2 of
msgid "A `TransformedPath` caches a non-affine transformed copy of the `~.path.Path`.  This cached copy is automatically updated when the non-affine part of the transform changes."
msgstr ""

#: matplotlib.transforms.TransformedPath:8 of
msgid "Paths are considered immutable by this class. Any update to the path's vertices/codes will not trigger a transform recomputation."
msgstr ""

#: matplotlib.transforms.TransformedPath:35
#: matplotlib.transforms.TransformedPath.__init__:8 of
msgid "**path** : `~.path.Path`"
msgstr ""

#: matplotlib.transforms.TransformedPath.get_fully_transformed_path:2 of
msgid "Return a fully-transformed copy of the child path."
msgstr ""

#: matplotlib.transforms.TransformedPath.get_transformed_path_and_affine:2 of
msgid "Return a copy of the child path, with the non-affine part of the transform already applied, along with the affine part of the path necessary to complete the transformation."
msgstr ""

#: matplotlib.transforms.TransformedPath.get_transformed_points_and_affine:2 of
msgid "Return a copy of the child path, with the non-affine part of the transform already applied, along with the affine part of the path necessary to complete the transformation.  Unlike :meth:`get_transformed_path_and_affine`, no interpolation will be performed."
msgstr ""

#: matplotlib.transforms.blended_transform_factory:5 of
msgid "A faster version of the blended transform is returned for the case where both child transforms are affine."
msgstr ""

#: matplotlib.transforms.composite_transform_factory:2 of
msgid "Create a new composite transform that is the result of applying transform a then transform b."
msgstr ""

#: matplotlib.transforms.composite_transform_factory:5 of
msgid "Shortcut versions of the blended transform are provided for the case where both child transforms are affine, or one or the other is the identity transform."
msgstr ""

#: matplotlib.transforms.composite_transform_factory:9 of
msgid "Composite transforms may also be created using the '+' operator, e.g.::"
msgstr ""

#: matplotlib.transforms.interval_contains:2 of
msgid "Check, inclusively, whether an interval includes a given value."
msgstr ""

#: matplotlib.transforms.interval_contains:8
#: matplotlib.transforms.interval_contains_open:8 of
msgid "**interval**"
msgstr ""

#: of
msgid "(float, float)"
msgstr ""

#: matplotlib.transforms.interval_contains:8
#: matplotlib.transforms.interval_contains_open:8 of
msgid "The endpoints of the interval."
msgstr ""

#: matplotlib.transforms.interval_contains:11
#: matplotlib.transforms.interval_contains_open:11 of
msgid "**val**"
msgstr ""

#: matplotlib.transforms.interval_contains:11
#: matplotlib.transforms.interval_contains_open:11 of
msgid "Value to check is within interval."
msgstr ""

#: matplotlib.transforms.interval_contains:16
#: matplotlib.transforms.interval_contains_open:16 of
msgid "Whether *val* is within the *interval*."
msgstr ""

#: matplotlib.transforms.interval_contains_open:2 of
msgid "Check, excluding endpoints, whether an interval includes a given value."
msgstr ""

#: matplotlib.transforms.nonsingular:2 of
msgid "Modify the endpoints of a range as needed to avoid singularities."
msgstr ""

#: matplotlib.transforms.nonsingular:8 matplotlib.transforms.nonsingular:41 of
msgid "**vmin, vmax**"
msgstr ""

#: matplotlib.transforms.nonsingular:8 of
msgid "The initial endpoints."
msgstr ""

#: matplotlib.transforms.nonsingular:12 of
msgid "**expander**"
msgstr ""

#: of
msgid "float, default: 0.001"
msgstr ""

#: matplotlib.transforms.nonsingular:11 of
msgid "Fractional amount by which *vmin* and *vmax* are expanded if the original interval is too small, based on *tiny*."
msgstr ""

#: matplotlib.transforms.nonsingular:19 of
msgid "**tiny**"
msgstr ""

#: of
msgid "float, default: 1e-15"
msgstr ""

#: matplotlib.transforms.nonsingular:15 of
msgid "Threshold for the ratio of the interval to the maximum absolute value of its endpoints.  If the interval is smaller than this, it will be expanded.  This value should be around 1e-15 or larger; otherwise the interval will be approaching the double precision resolution limit."
msgstr ""

#: matplotlib.transforms.nonsingular:22 of
msgid "**increasing**"
msgstr ""

#: matplotlib.transforms.nonsingular:22 of
msgid "If True, swap *vmin*, *vmax* if *vmin* > *vmax*."
msgstr ""

#: matplotlib.transforms.nonsingular:27 of
msgid "Endpoints, expanded and/or swapped if necessary. If either input is inf or NaN, or if both inputs are 0 or very close to zero, it returns -*expander*, *expander*."
msgstr ""

#: matplotlib.transforms.offset_copy:2 of
msgid "Return a new transform with an added offset."
msgstr ""

#: matplotlib.transforms.offset_copy:8 of
msgid "**trans** : `Transform` subclass"
msgstr ""

#: matplotlib.transforms.offset_copy:7 of
msgid "Transform subclass"
msgstr ""

#: matplotlib.transforms.offset_copy:8 of
msgid "Any transform, to which offset will be applied."
msgstr ""

#: matplotlib.transforms.offset_copy:11 of
msgid "**fig** : `~matplotlib.figure.Figure`, default: None"
msgstr ""

#: matplotlib.transforms.offset_copy:10 of
msgid "Figure, default: None"
msgstr ""

#: matplotlib.transforms.offset_copy:11 of
msgid "Current figure. It can be None if *units* are 'dots'."
msgstr ""

#: matplotlib.transforms.offset_copy:14 of
msgid "**x, y**"
msgstr ""

#: of
msgid "float, default: 0.0"
msgstr ""

#: matplotlib.transforms.offset_copy:14 of
msgid "The offset to apply."
msgstr ""

#: matplotlib.transforms.offset_copy:17 of
msgid "**units**"
msgstr ""

#: of
msgid "{'inches', 'points', 'dots'}, default: 'inches'"
msgstr ""

#: matplotlib.transforms.offset_copy:17 of
msgid "Units of the offset."
msgstr ""

#: matplotlib.transforms.offset_copy:34 of
msgid "`Transform` subclass"
msgstr ""

#: matplotlib.transforms.offset_copy:22 of
msgid "Transform with applied offset."
msgstr ""

