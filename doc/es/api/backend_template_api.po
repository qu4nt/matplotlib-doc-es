msgid ""
msgstr ""
"Project-Id-Version: matplotlib\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-01 17:05-0400\n"
"PO-Revision-Date: 2022-11-01 21:46\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: matplotlib\n"
"X-Crowdin-Project-ID: 502106\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /[qu4nt.matplotlib-doc-es] main/doc/en/api/backend_template_api.po\n"
"X-Crowdin-File-ID: 1746\n"
"Language: es_ES\n"

#: ../../api/backend_template_api.rst:2
msgid ":mod:`.backend_template`"
msgstr ""

#: matplotlib.backends.backend_template:1 of
msgid "A fully functional, do-nothing backend intended as a template for backend writers.  It is fully functional in that you can select it as a backend e.g. with ::"
msgstr ""

#: matplotlib.backends.backend_template:8 of
msgid "and your program will (should!) run without error, though no output is produced.  This provides a starting point for backend writers; you can selectively implement drawing methods (`~.RendererTemplate.draw_path`, `~.RendererTemplate.draw_image`, etc.) and slowly see your figure come to life instead having to have a full blown implementation before getting any results."
msgstr ""

#: matplotlib.backends.backend_template:14 of
msgid "Copy this file to a directory outside of the Matplotlib source tree, somewhere where Python can import it (by adding the directory to your ``sys.path`` or by packaging it as a normal Python package); if the backend is importable as ``import my.backend`` you can then select it using ::"
msgstr ""

#: matplotlib.backends.backend_template:22 of
msgid "If your backend implements support for saving figures (i.e. has a `print_xyz` method), you can register it as the default handler for a given file type::"
msgstr ""

#: matplotlib.backends.backend_template.FigureCanvasTemplate:1 of
msgid "Bases: :py:class:`matplotlib.backend_bases.FigureCanvasBase`"
msgstr "Bases: :py:class:`matplotlib.backend_bases.FigureCanvasBase`"

#: matplotlib.backends.backend_template.FigureCanvasTemplate:2 of
msgid "The canvas the figure renders into.  Calls the draw and print fig methods, creates the renderers, etc."
msgstr ""

#: matplotlib.backends.backend_template.FigureCanvasTemplate:5 of
msgid "Note: GUI templates will want to connect events for button presses, mouse movements and key presses to functions that call the base class methods button_press_event, button_release_event, motion_notify_event, key_press_event, and key_release_event.  See the implementations of the interactive backends for examples."
msgstr ""

#: matplotlib.backends.backend_template.FigureCanvasTemplate of
msgid "Attributes"
msgstr "Atributos"

#: matplotlib.backends.backend_template.FigureCanvasTemplate:27 of
msgid "**figure** : `matplotlib.figure.Figure`"
msgstr ""

#: matplotlib.backends.backend_template.FigureCanvasTemplate:26 of
msgid "matplotlib.figure.Figure"
msgstr "matplotlib.figure.Figure"

#: matplotlib.backends.backend_template.FigureCanvasTemplate:26 of
msgid "A high-level Figure instance"
msgstr ""

#: matplotlib.backends.backend_template.FigureCanvasTemplate.draw:2 of
msgid "Draw the figure using the renderer."
msgstr ""

#: matplotlib.backends.backend_template.FigureCanvasTemplate.draw:4 of
msgid "It is important that this method actually walk the artist tree even if not output is produced because this will trigger deferred work (like computing limits auto-limits and tick values) that users may want access to before saving to disk."
msgstr ""

#: matplotlib.backends.backend_template.FigureCanvasTemplate.get_default_filetype:2
#: of
msgid "Return the default savefig file format as specified in :rc:`savefig.format`."
msgstr ""

#: matplotlib.backends.backend_template.FigureCanvasTemplate.get_default_filetype:5
#: of
msgid "The returned string does not include a period. This method is overridden in backends that only support a single file type."
msgstr ""

#: matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo:2 of
msgid "Write out format foo."
msgstr ""

#: matplotlib.backends.backend_template.FigureCanvasTemplate.print_foo:4 of
msgid "This method is normally called via `.Figure.savefig` and `.FigureCanvasBase.print_figure`, which take care of setting the figure facecolor, edgecolor, and dpi to the desired output values, and will restore them to the original values.  Therefore, `print_foo` does not need to handle these settings."
msgstr ""

#: matplotlib.backends.backend_template.FigureManagerTemplate:1 of
msgid "Bases: :py:class:`matplotlib.backend_bases.FigureManagerBase`"
msgstr "Bases: :py:class:`matplotlib.backend_bases.FigureManagerBase`"

#: matplotlib.backends.backend_template.FigureManagerTemplate:2 of
msgid "Helper class for pyplot mode, wraps everything up into a neat bundle."
msgstr ""

#: matplotlib.backends.backend_template.FigureManagerTemplate:4 of
msgid "For non-interactive backends, the base class is sufficient."
msgstr ""

#: matplotlib.backends.backend_template.GraphicsContextTemplate:1 of
msgid "Bases: :py:class:`matplotlib.backend_bases.GraphicsContextBase`"
msgstr "Bases: :py:class:`matplotlib.backend_bases.GraphicsContextBase`"

#: matplotlib.backends.backend_template.GraphicsContextTemplate:2 of
msgid "The graphics context provides the color, line styles, etc...  See the cairo and postscript backends for examples of mapping the graphics context attributes (cap styles, join styles, line widths, colors) to a particular backend.  In cairo this is done by wrapping a cairo.Context object and forwarding the appropriate calls to it using a dictionary mapping styles to gdk constants.  In Postscript, all the work is done by the renderer, mapping line styles to postscript calls."
msgstr ""

#: matplotlib.backends.backend_template.GraphicsContextTemplate:10 of
msgid "If it's more appropriate to do the mapping at the renderer level (as in the postscript backend), you don't need to override any of the GC methods. If it's more appropriate to wrap an instance (as in the cairo backend) and do the mapping here, you'll need to override several of the setter methods."
msgstr ""

#: matplotlib.backends.backend_template.GraphicsContextTemplate:16 of
msgid "The base GraphicsContext stores colors as a RGB tuple on the unit interval, e.g., (0.5, 0.0, 1.0). You may need to map this to colors appropriate for your backend."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate:1 of
msgid "Bases: :py:class:`matplotlib.backend_bases.RendererBase`"
msgstr "Bases: :py:class:`matplotlib.backend_bases.RendererBase`"

#: matplotlib.backends.backend_template.RendererTemplate:2 of
msgid "The renderer handles drawing/rendering operations."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate:4 of
msgid "This is a minimal do-nothing class that can be used to get started when writing a new backend.  Refer to `backend_bases.RendererBase` for documentation of the methods."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:2 of
msgid "Draw an RGBA image."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image
#: matplotlib.backends.backend_template.RendererTemplate.draw_text
#: matplotlib.backends.backend_template.RendererTemplate.points_to_pixels of
msgid "Parameters"
msgstr "Par√°metros"

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:8
#: matplotlib.backends.backend_template.RendererTemplate.draw_text:8 of
msgid "**gc** : `.GraphicsContextBase`"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:7
#: matplotlib.backends.backend_template.RendererTemplate.draw_text:7 of
msgid "GraphicsContextBase"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:8 of
msgid "A graphics context with clipping information."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:12
#: matplotlib.backends.backend_template.RendererTemplate.draw_text:11 of
msgid "**x**"
msgstr "**x**"

#: of
msgid "scalar"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:11 of
msgid "The distance in physical units (i.e., dots or pixels) from the left hand side of the canvas."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:16
#: matplotlib.backends.backend_template.RendererTemplate.draw_text:14 of
msgid "**y**"
msgstr "**y**"

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:15 of
msgid "The distance in physical units (i.e., dots or pixels) from the bottom side of the canvas."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:19 of
msgid "**im**"
msgstr ""

#: of
msgid "(N, M, 4) array-like of np.uint8"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:19 of
msgid "An array of RGBA pixels."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:43 of
msgid "**transform** : `matplotlib.transforms.Affine2DBase`"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:42 of
msgid "matplotlib.transforms.Affine2DBase"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_image:22 of
msgid "If and only if the concrete backend is written such that :meth:`option_scale_image` returns ``True``, an affine transformation (i.e., an `.Affine2DBase`) *may* be passed to :meth:`draw_image`.  The translation vector of the transformation is given in physical units (i.e., dots or pixels). Note that the transformation does not override *x* and *y*, and has to be applied *before* translating the result by *x* and *y* (this can be accomplished by adding *x* and *y* to the translation vector defined by *transform*)."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_path:2 of
msgid "Draw a `~.path.Path` instance using the given affine transform."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:2 of
msgid "Draw the text instance."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:8 of
msgid "The graphics context."
msgstr ""

#: of
msgid "float"
msgstr "float"

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:11 of
msgid "The x location of the text in display coords."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:14 of
msgid "The y location of the text baseline in display coords."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:17 of
msgid "**s**"
msgstr "**s**"

#: of
msgid "str"
msgstr "str"

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:17 of
msgid "The text string."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:20 of
msgid "**prop** : `matplotlib.font_manager.FontProperties`"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:19 of
msgid "matplotlib.font_manager.FontProperties"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:20 of
msgid "The font properties."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:23 of
msgid "**angle**"
msgstr "**angle**"

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:23 of
msgid "The rotation angle in degrees anti-clockwise."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:34 of
msgid "**mtext** : `matplotlib.text.Text`"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:33 of
msgid "matplotlib.text.Text"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:26 of
msgid "The original text object to be rendered."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:37 of
msgid "Notes"
msgstr "Notes"

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:38 of
msgid "**Note for backend implementers:**"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:40 of
msgid "When you are trying to determine if you have gotten your bounding box right (which is what enables the text layout/alignment to work properly), it helps to change the line in text.py::"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.draw_text:46 of
msgid "to if 1, and then the actual bounding box will be plotted along with your text."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.flipy:2 of
msgid "Return whether y values increase from top to bottom."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.flipy:4 of
msgid "Note that this only affects drawing of texts and images."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.get_canvas_width_height:2
#: of
msgid "Return the canvas width and height in display coords."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.get_text_width_height_descent:2
#: of
msgid "Get the width, height, and descent (offset from the bottom to the baseline), in display coords, of the string *s* with `.FontProperties` *prop*."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.new_gc:2 of
msgid "Return an instance of a `.GraphicsContextBase`."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.points_to_pixels:2 of
msgid "Convert points to display units."
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.points_to_pixels:4 of
msgid "You need to override this function (unless your backend doesn't have a dpi, e.g., postscript or svg).  Some imaging systems assume some value for pixels per inch::"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.points_to_pixels:13 of
msgid "**points**"
msgstr "**puntos**"

#: of
msgid "float or array-like"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.points_to_pixels:13 of
msgid "a float or a numpy array of float"
msgstr ""

#: matplotlib.backends.backend_template.RendererTemplate.points_to_pixels of
msgid "Returns"
msgstr "Devuelve"

#: matplotlib.backends.backend_template.RendererTemplate.points_to_pixels:30 of
msgid "Points converted to pixels"
msgstr ""

#: matplotlib.backends.backend_template.draw_if_interactive:2 of
msgid "For image backends - is not required. For GUI backends - this should be overridden if drawing should be done in interactive python mode."
msgstr ""

#: matplotlib.backends.backend_template.new_figure_manager:2 of
msgid "Create a new figure manager instance."
msgstr ""

#: matplotlib.backends.backend_template.new_figure_manager_given_figure:2 of
msgid "Create a new figure manager instance for the given figure."
msgstr ""

#: matplotlib.backends.backend_template.show:2 of
msgid "For image backends - is not required. For GUI backends - show() is usually the last line of a pyplot script and tells the backend that it is time to draw.  In interactive mode, this should do nothing."
msgstr ""

