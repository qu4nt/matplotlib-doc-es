msgid ""
msgstr ""
"Project-Id-Version: matplotlib\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-01 17:05-0400\n"
"PO-Revision-Date: 2022-03-10 02:52\n"
"Last-Translator: \n"
"Language-Team: Spanish\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: matplotlib\n"
"X-Crowdin-Project-ID: 502106\n"
"X-Crowdin-Language: es-ES\n"
"X-Crowdin-File: /[qu4nt.matplotlib-doc-es] main/doc/en/users/explain/interactive_guide.po\n"
"X-Crowdin-File-ID: 3368\n"
"Language: es_ES\n"

#: ../../users/explain/interactive_guide.rst:10
msgid "Interactive figures and asynchronous programming"
msgstr "Figuras interactivas y programación asíncrona"

#: ../../users/explain/interactive_guide.rst:12
msgid "Matplotlib supports rich interactive figures by embedding figures into a GUI window.  The basic interactions of panning and zooming in an Axes to inspect your data is 'baked in' to Matplotlib.  This is supported by a full mouse and keyboard event handling system that you can use to build sophisticated interactive graphs."
msgstr "Matplotlib soporta figuras interactivas enriquecidas mediante la incrustación de figuras en una ventana GUI.  Se han incorporado a Matplotlib las interacciones básicas de desplazamiento y zoom en un eje para inspeccionar los datos.  Esto es apoyado por un sistema completo de manejo de eventos del ratón y del teclado que puedes usar para construir sofisticados gráficos interactivos."

#: ../../users/explain/interactive_guide.rst:18
msgid "This guide is meant to be an introduction to the low-level details of how Matplotlib integration with a GUI event loop works.  For a more practical introduction to the Matplotlib event API see :ref:`event handling system <event-handling-tutorial>`, `Interactive Tutorial <https://github.com/matplotlib/interactive_tutorial>`__, and `Interactive Applications using Matplotlib <http://www.amazon.com/Interactive-Applications-using-Matplotlib-Benjamin/dp/1783988843>`__."
msgstr "Esta guía pretende ser una introducción a los detalles de bajo nivel de cómo funciona la integración de Matplotlib con un bucle de eventos de GUI.  Para una introducción más práctica a la API de eventos de Matplotlib consulta :ref:`sistema de manejo de eventos <event-handling-tutorial>`, `Tutorial Interactivo <https://github.com/matplotlib/interactive_tutorial>`__, y `Aplicaciones Interactivas usando Matplotlib <http://www.amazon.com/Interactive-Applications-using-Matplotlib-Benjamin/dp/1783988843>`__."

#: ../../users/explain/interactive_guide.rst:27
msgid "Event loops"
msgstr "Bucles de eventos"

#: ../../users/explain/interactive_guide.rst:29
msgid "Fundamentally, all user interaction (and networking) is implemented as an infinite loop waiting for events from the user (via the OS) and then doing something about it.  For example, a minimal Read Evaluate Print Loop (REPL) is ::"
msgstr ""

#: ../../users/explain/interactive_guide.rst:42
msgid "This is missing many niceties (for example, it exits on the first exception!), but is representative of the event loops that underlie all terminals, GUIs, and servers [#f1]_.  In general the *Read* step is waiting on some sort of I/O -- be it user input or the network -- while the *Evaluate* and *Print* are responsible for interpreting the input and then **doing** something about it."
msgstr ""

#: ../../users/explain/interactive_guide.rst:49
msgid "In practice we interact with a framework that provides a mechanism to register callbacks to be run in response to specific events rather than directly implement the I/O loop [#f2]_.  For example \"when the user clicks on this button, please run this function\" or \"when the user hits the 'z' key, please run this other function\".  This allows users to write reactive, event-driven, programs without having to delve into the nitty-gritty [#f3]_ details of I/O.  The core event loop is sometimes referred to as \"the main loop\" and is typically started, depending on the library, by methods with names like ``_exec``, ``run``, or ``start``."
msgstr ""

#: ../../users/explain/interactive_guide.rst:61
msgid "All GUI frameworks (Qt, Wx, Gtk, tk, OSX, or web) have some method of capturing user interactions and passing them back to the application (for example ``Signal`` / ``Slot`` framework in Qt) but the exact details depend on the toolkit.  Matplotlib has a :ref:`backend <what-is-a-backend>` for each GUI toolkit we support which uses the toolkit API to bridge the toolkit UI events into Matplotlib's :ref:`event handling system <event-handling-tutorial>`.  You can then use `.FigureCanvasBase.mpl_connect` to connect your function to Matplotlib's event handling system.  This allows you to directly interact with your data and write GUI toolkit agnostic user interfaces."
msgstr ""

#: ../../users/explain/interactive_guide.rst:77
msgid "Command prompt integration"
msgstr ""

#: ../../users/explain/interactive_guide.rst:79
msgid "So far, so good.  We have the REPL (like the IPython terminal) that lets us interactively send code to the interpreter and get results back.  We also have the GUI toolkit that runs an event loop waiting for user input and lets us register functions to be run when that happens.  However, if we want to do both we have a problem: the prompt and the GUI event loop are both infinite loops that each think *they* are in charge!  In order for both the prompt and the GUI windows to be responsive we need a method to allow the loops to 'timeshare' :"
msgstr ""

#: ../../users/explain/interactive_guide.rst:88
msgid "let the GUI main loop block the python process when you want interactive windows"
msgstr ""

#: ../../users/explain/interactive_guide.rst:90
msgid "let the CLI main loop block the python process and intermittently run the GUI loop"
msgstr ""

#: ../../users/explain/interactive_guide.rst:92
msgid "fully embed python in the GUI (but this is basically writing a full application)"
msgstr ""

#: ../../users/explain/interactive_guide.rst:98
msgid "Blocking the prompt"
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid ":py:obj:`pyplot.show <matplotlib.pyplot.show>`"
msgstr ":py:obj:`pyplot.show <matplotlib.pyplot.show>`"

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid "Display all open figures."
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid ":py:obj:`pyplot.pause <matplotlib.pyplot.pause>`"
msgstr ":py:obj:`pyplot.pause <matplotlib.pyplot.pause>`"

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid "Run the GUI event loop for *interval* seconds."
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
msgid ":py:obj:`backend_bases.FigureCanvasBase.start_event_loop <matplotlib.backend_bases.FigureCanvasBase.start_event_loop>`"
msgstr ":py:obj:`backend_bases.FigureCanvasBase.start_event_loop <matplotlib.backend_bases.FigureCanvasBase.start_event_loop>`"

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
msgid "Start a blocking event loop."
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
msgid ":py:obj:`backend_bases.FigureCanvasBase.stop_event_loop <matplotlib.backend_bases.FigureCanvasBase.stop_event_loop>`"
msgstr ":py:obj:`backend_bases.FigureCanvasBase.stop_event_loop <matplotlib.backend_bases.FigureCanvasBase.stop_event_loop>`"

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
msgid "Stop the current blocking event loop."
msgstr ""

#: ../../users/explain/interactive_guide.rst:111
msgid "The simplest \"integration\" is to start the GUI event loop in 'blocking' mode and take over the CLI.  While the GUI event loop is running you can not enter new commands into the prompt (your terminal may echo the characters typed into the terminal, but they will not be sent to the Python interpreter because it is busy running the GUI event loop), but the figure windows will be responsive.  Once the event loop is stopped (leaving any still open figure windows non-responsive) you will be able to use the prompt again.  Re-starting the event loop will make any open figure responsive again (and will process any queued up user interaction)."
msgstr ""

#: ../../users/explain/interactive_guide.rst:122
msgid "To start the event loop until all open figures are closed, use `.pyplot.show` as ::"
msgstr ""

#: ../../users/explain/interactive_guide.rst:127
msgid "To start the event loop for a fixed amount of time (in seconds) use `.pyplot.pause`."
msgstr ""

#: ../../users/explain/interactive_guide.rst:130
msgid "If you are not using `.pyplot` you can start and stop the event loops via `.FigureCanvasBase.start_event_loop` and `.FigureCanvasBase.stop_event_loop`. However, in most contexts where you would not be using `.pyplot` you are embedding Matplotlib in a large GUI application and the GUI event loop should already be running for the application."
msgstr ""

#: ../../users/explain/interactive_guide.rst:137
msgid "Away from the prompt, this technique can be very useful if you want to write a script that pauses for user interaction, or displays a figure between polling for additional data.  See :ref:`interactive_scripts` for more details."
msgstr ""

#: ../../users/explain/interactive_guide.rst:144
msgid "Input hook integration"
msgstr ""

#: ../../users/explain/interactive_guide.rst:146
msgid "While running the GUI event loop in a blocking mode or explicitly handling UI events is useful, we can do better!  We really want to be able to have a usable prompt **and** interactive figure windows."
msgstr ""

#: ../../users/explain/interactive_guide.rst:150
msgid "We can do this using the 'input hook' feature of the interactive prompt.  This hook is called by the prompt as it waits for the user to type (even for a fast typist the prompt is mostly waiting for the human to think and move their fingers).  Although the details vary between prompts the logic is roughly"
msgstr ""

#: ../../users/explain/interactive_guide.rst:156
msgid "start to wait for keyboard input"
msgstr ""

#: ../../users/explain/interactive_guide.rst:157
msgid "start the GUI event loop"
msgstr ""

#: ../../users/explain/interactive_guide.rst:158
msgid "as soon as the user hits a key, exit the GUI event loop and handle the key"
msgstr ""

#: ../../users/explain/interactive_guide.rst:159
msgid "repeat"
msgstr "repite"

#: ../../users/explain/interactive_guide.rst:161
msgid "This gives us the illusion of simultaneously having interactive GUI windows and an interactive prompt.  Most of the time the GUI event loop is running, but as soon as the user starts typing the prompt takes over again."
msgstr "Esto nos da la ilusión de tener simultáneamente ventanas GUI interactivas y un prompt interactivo. La mayor parte del tiempo el bucle de eventos de la GUI se está ejecutando, pero tan pronto como el usuario comienza a escribir el prompt toma el control de nuevo."

#: ../../users/explain/interactive_guide.rst:166
msgid "This time-share technique only allows the event loop to run while python is otherwise idle and waiting for user input.  If you want the GUI to be responsive during long running code it is necessary to periodically flush the GUI event queue as described :ref:`above <spin_event_loop>`.  In this case it is your code, not the REPL, which is blocking the process so you need to handle the \"time-share\" manually. Conversely, a very slow figure draw will block the prompt until it finishes drawing."
msgstr "Esta técnica de tiempo compartido sólo permite que el bucle de eventos se ejecute mientras python está inactivo y esperando la respuesta del usuario.  Si quieres que la interfaz gráfica de usuario responda durante la ejecución de un código largo es necesario vaciar periódicamente la cola de eventos de esa interfaz gráfica como se describe :ref:`above <spin_event_loop>`.  En este caso es su código, no el REPL, el que está bloqueando el proceso por lo que necesita manejar el \"tiempo compartido\" manualmente. A la inversa, el dibujo muy lento de una figura bloqueará el prompt hasta que termine de dibujarse."

#: ../../users/explain/interactive_guide.rst:176
msgid "Full embedding"
msgstr "Inserción completa"

#: ../../users/explain/interactive_guide.rst:178
msgid "It is also possible to go the other direction and fully embed figures (and a `Python interpreter <https://docs.python.org/3/extending/embedding.html>`__) in a rich native application.  Matplotlib provides classes for each toolkit which can be directly embedded in GUI applications (this is how the built-in windows are implemented!).  See :ref:`user_interfaces` for more details."
msgstr "También es posible ir en la otra dirección e incrustar completamente las figuras (y un intérprete de  `Python interpreter <https://docs.python.org/3/extending/embedding.html>`__) en una aplicación nativa enrriquecida. Matplotlib proporciona clases para cada juego de herramientas que pueden ser incrustadas directamente en aplicaciones GUI (¡así es como se implementan las ventanas incorporadas!).  Ver :ref:`user_interfaces` para más detalles."

#: ../../users/explain/interactive_guide.rst:190
msgid "Scripts and functions"
msgstr "Scripts y funciones"

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:252:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid ":py:obj:`backend_bases.FigureCanvasBase.flush_events <matplotlib.backend_bases.FigureCanvasBase.flush_events>`"
msgstr ":py:obj:`backend_bases.FigureCanvasBase.flush_events <matplotlib.backend_bases.FigureCanvasBase.flush_events>`"

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:252:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid "Flush the GUI events for the figure."
msgstr "Limpiar los eventos de la interfaz gráfica de usuario para la figura."

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:252:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid ":py:obj:`backend_bases.FigureCanvasBase.draw_idle <matplotlib.backend_bases.FigureCanvasBase.draw_idle>`"
msgstr ":py:obj:`backend_bases.FigureCanvasBase.draw_idle <matplotlib.backend_bases.FigureCanvasBase.draw_idle>`"

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:252:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid "Request a widget redraw once control returns to the GUI event loop."
msgstr "Solicitar el redibujo del widget una vez que el control vuelve al bucle de eventos de la GUI."

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid ":py:obj:`figure.Figure.ginput <matplotlib.figure.Figure.ginput>`"
msgstr ":py:obj:`figure.Figure.ginput <matplotlib.figure.Figure.ginput>`"

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid "Blocking call to interact with a figure."
msgstr "Bloquear llamada para interactuar con una figura."

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid ":py:obj:`pyplot.ginput <matplotlib.pyplot.ginput>`"
msgstr ":py:obj:`pyplot.ginput <matplotlib.pyplot.ginput>`"

#: ../../users/explain/interactive_guide.rst:206
msgid "There are several use-cases for using interactive figures in scripts:"
msgstr "Hay varios casos de uso para utilizar figuras interactivas en los scripts:"

#: ../../users/explain/interactive_guide.rst:208
msgid "capture user input to steer the script"
msgstr "capturar la entrada del usuario para dirigir el script"

#: ../../users/explain/interactive_guide.rst:209
msgid "progress updates as a long running script progresses"
msgstr "actualizaciones de progreso a medida que avanza un script de ejecución larga"

#: ../../users/explain/interactive_guide.rst:210
msgid "streaming updates from a data source"
msgstr "actualizaciones de flujo desde una fuente de datos"

#: ../../users/explain/interactive_guide.rst:213
msgid "Blocking functions"
msgstr "Funciones de bloqueo"

#: ../../users/explain/interactive_guide.rst:215
msgid "If you only need to collect points in an Axes you can use `.figure.Figure.ginput` or more generally the tools from `.blocking_input` the tools will take care of starting and stopping the event loop for you.  However if you have written some custom event handling or are using `.widgets` you will need to manually run the GUI event loop using the methods described :ref:`above <cp_block_the_prompt>`."
msgstr "Si sólo necesitas recoger puntos en un Eje, puedes utilizar `.figure.Figure.ginput` o, en general, las herramientas de `.blocking_input` las herramientas se encargarán de iniciar y detener el bucle de eventos por Ud.  Sin embargo, si has escrito algún manejo de eventos personalizado o está usando `.widgets` tendrás que ejecutar manualmente el bucle de eventos de la GUI usando los métodos descritos :ref:`above <cp_block_the_prompt>`."

#: ../../users/explain/interactive_guide.rst:222
msgid "You can also use the methods described in :ref:`cp_block_the_prompt` to suspend run the GUI event loop.  Once the loop exits your code will resume.  In general, any place you would use `time.sleep` you can use `.pyplot.pause` instead with the added benefit of interactive figures."
msgstr "También puedes utilizar los métodos descritos en  :ref:`cp_block_the_prompt` para suspender la ejecución del bucle de eventos de la GUI.  Una vez que el bucle finalice, su código se reanudará.  En general, en cualquier lugar en el que se utilizaría `time.sleep` puedes utilizar `.pyplot.pause` en su lugar con el beneficio añadido de las figuras interactivas."

#: ../../users/explain/interactive_guide.rst:227
msgid "For example, if you want to poll for data you could use something like ::"
msgstr "Por ejemplo, si quiere sondear los datos podría usar algo como ::"

#: ../../users/explain/interactive_guide.rst:237
msgid "which would poll for new data and update the figure at 1Hz."
msgstr "que sondearía los nuevos datos y actualizaría la figura a 1Hz."

#: ../../users/explain/interactive_guide.rst:242
msgid "Explicitly spinning the event Loop"
msgstr "Girar explícitamente el bucle de eventos"

#: ../../users/explain/interactive_guide.rst:253
msgid "If you have open windows that have pending UI events (mouse clicks, button presses, or draws) you can explicitly process those events by calling `.FigureCanvasBase.flush_events`. This will run the GUI event loop until all UI events currently waiting have been processed.  The exact behavior is backend-dependent but typically events on all figure are processed and only events waiting to be processed (not those added during processing) will be handled."
msgstr "Si tiene ventanas abiertas con eventos pendientes en la interfaz del usuario (clics del ratón, pulsaciones de botones o gráficos), puede procesar explícitamente esos eventos llamando a `.FigureCanvasBase.flush_events`. Esto ejecutará el bucle de eventos de la interfaz gráfica de usuario hasta que se hayan procesado todos los eventos de interfaz de usuario que estén pendientes. El comportamiento exacto depende del backend, pero normalmente se procesan los eventos de todas las figuras y sólo se gestionan los eventos en espera de ser procesados (no los añadidos durante el procesamiento)."

#: ../../users/explain/interactive_guide.rst:261
msgid "For example ::"
msgstr "Por ejemplo ::"

#: ../../users/explain/interactive_guide.rst:281
msgid "While this will feel a bit laggy (as we are only processing user input every 100ms whereas 20-30ms is what feels \"responsive\") it will respond."
msgstr "Aunque esto se sienta un poco lento (ya que sólo estamos procesando la entrada del usuario cada 100ms, mientras que 20-30ms es lo que se siente \"responsivo\"), responderá."

#: ../../users/explain/interactive_guide.rst:285
msgid "If you make changes to the plot and want it re-rendered you will need to call `~.FigureCanvasBase.draw_idle` to request that the canvas be re-drawn.  This method can be thought of *draw_soon* in analogy to `asyncio.loop.call_soon`."
msgstr "Si realiza cambios en el gráfico y quiere que se vuelva a renderizar tendrá que llamar a `~.FigureCanvasBase.draw_idle` para solicitar que se vuelva a dibujar el lienzo. Este método puede ser pensado como *draw_soon* en analogía con `asyncio.loop.call_soon`."

#: ../../users/explain/interactive_guide.rst:290
msgid "We can add this our example above as ::"
msgstr "Podemos añadir este nuestro ejemplo anterior como ::"

#: ../../users/explain/interactive_guide.rst:304
msgid "The more frequently you call `.FigureCanvasBase.flush_events` the more responsive your figure will feel but at the cost of spending more resources on the visualization and less on your computation."
msgstr "Cuanto más frecuentemente se llame a `.FigureCanvasBase.flush_events` más responsiva se sentirá la figura, pero a costa de destinar más recursos a la visualización y menos a su cómputo."

#: ../../users/explain/interactive_guide.rst:312
msgid "Stale artists"
msgstr "Artists caducados"

#: ../../users/explain/interactive_guide.rst:314
msgid "Artists (as of Matplotlib 1.5) have a **stale** attribute which is `True` if the internal state of the artist has changed since the last time it was rendered. By default the stale state is propagated up to the Artists parents in the draw tree, e.g., if the color of a `.Line2D` instance is changed, the `.axes.Axes` and `.figure.Figure` that contain it will also be marked as \"stale\".  Thus, ``fig.stale`` will report if any artist in the figure has been modified and is out of sync with what is displayed on the screen.  This is intended to be used to determine if ``draw_idle`` should be called to schedule a re-rendering of the figure."
msgstr "Los artists (a partir de Matplotlib 1.5) tienen un atributo **stale** que es `True` si el estado interno del artist ha cambiado desde la última vez que se renderizó. Por defecto, el estado caducado se propaga a los padres de los Artists en la estructura del dibujo, por ejemplo, si el color de una instancia de `.Line2D` se cambia, el `.axes.Axes` y `.figure.Figure` que lo contienen también se marcarán como \"caducado\".  Así, ``fig.stale`` informará si algún artist de la figura ha sido modificado y no está sincronizado con lo que se muestra en la pantalla.  Esto está pensado para determinar si se debe llamar a ``draw_idle`` para programar una nueva renderización de la figura."

#: ../../users/explain/interactive_guide.rst:325
msgid "Each artist has a `.Artist.stale_callback` attribute which holds a callback with the signature ::"
msgstr "Cada artist tiene un atributo `.Artist.stale_callback` que contiene una llamada de retorno con la firma ::"

#: ../../users/explain/interactive_guide.rst:331
msgid "which by default is set to a function that forwards the stale state to the artist's parent.   If you wish to suppress a given artist from propagating set this attribute to None."
msgstr "que, por defecto, se establece como una función que reenvía el estado caducado al padre del artist. Si desea suprimir la propagación de un artist determinado, establezca este atributo como None."

#: ../../users/explain/interactive_guide.rst:335
msgid "`.figure.Figure` instances do not have a containing artist and their default callback is `None`.  If you call `.pyplot.ion` and are not in ``IPython`` we will install a callback to invoke `~.backend_bases.FigureCanvasBase.draw_idle` whenever the `.figure.Figure` becomes stale.  In ``IPython`` we use the ``'post_execute'`` hook to invoke `~.backend_bases.FigureCanvasBase.draw_idle` on any stale figures after having executed the user's input, but before returning the prompt to the user.  If you are not using `.pyplot` you can use the callback `Figure.stale_callback` attribute to be notified when a figure has become stale."
msgstr "Las instancias de `.figure.Figure` no tienen un artist contenedor y su retorno por defecto es `None`.  Si llama a `.pyplot.ion` y no está en ``IPython`` instalaremos una llamada de retorno para invocar a `~.backend_bases.FigureCanvasBase.draw_idle` cada vez que el `.figure.Figure` caduque.  En ``IPython`` utilizamos el hook ``'post_execute`` para invocar a `~.backend_bases.FigureCanvasBase.draw_idle` en cualquier figura caduca después de haber ejecutado la entrada del usuario, pero antes de devolver el prompt al usuario.  Si no utiliza `.pyplot`, puede utilizar el atributo de retorno `Figure.stale_callback` para que le notifique cuando una figura se ha quedado caduca."

#: ../../users/explain/interactive_guide.rst:351
msgid "Idle draw"
msgstr "Dibujo inactivo"

#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid ":py:obj:`backend_bases.FigureCanvasBase.draw <matplotlib.backend_bases.FigureCanvasBase.draw>`"
msgstr ":py:obj:`backend_bases.FigureCanvasBase.draw <matplotlib.backend_bases.FigureCanvasBase.draw>`"

#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid "Render the `.Figure`."
msgstr "Renderiza la `.Figure`."

#: ../../users/explain/interactive_guide.rst:362
msgid "In almost all cases, we recommend using `backend_bases.FigureCanvasBase.draw_idle` over `backend_bases.FigureCanvasBase.draw`.  ``draw`` forces a rendering of the figure whereas ``draw_idle`` schedules a rendering the next time the GUI window is going to re-paint the screen.  This improves performance by only rendering pixels that will be shown on the screen.  If you want to be sure that the screen is updated as soon as possible do ::"
msgstr "En casi todos los casos, recomendamos utilizar `backend_bases.FigureCanvasBase.draw_idle` en lugar de `backend_bases.FigureCanvasBase.draw`.  ``draw`` fuerza una renderización de la figura mientras que ``draw_idle`` programa una renderización la próxima vez que la ventana GUI vaya a repintar la pantalla.  Esto mejora el rendimiento al renderizar sólo los píxeles que se mostrarán en la pantalla. Si quiere asegurarse de que la pantalla se actualiza lo antes posible hágalo ::"

#: ../../users/explain/interactive_guide.rst:376
msgid "Threading"
msgstr "Subprocesos"

#: ../../users/explain/interactive_guide.rst:378
msgid "Most GUI frameworks require that all updates to the screen, and hence their main event loop, run on the main thread.  This makes pushing periodic updates of a plot to a background thread impossible. Although it seems backwards, it is typically easier to push your computations to a background thread and periodically update the figure on the main thread."
msgstr "La mayoría de los frameworks de GUI requieren que todas las actualizaciones de la pantalla, y por tanto su bucle de eventos principal, se ejecuten en el subproceso principal. Esto hace que sea imposible enviar las actualizaciones periódicas de un gráfico a un segundo plano. Aunque parezca un retroceso, normalmente es más fácil pasar los cálculos a un subproceso en segundo plano y actualizar periódicamente la figura en el subproceso principal."

#: ../../users/explain/interactive_guide.rst:385
msgid "In general Matplotlib is not thread safe.  If you are going to update `.Artist` objects in one thread and draw from another you should make sure that you are locking in the critical sections."
msgstr "En general, Matplotlib no es seguro para subprocesos.  Si va a actualizar objetos `.Artist` en un subproceso y dibujar desde otro, debe asegurarse de bloquear las secciones críticas."

#: ../../users/explain/interactive_guide.rst:392
msgid "Eventloop integration mechanism"
msgstr "Mecanismo de integración Eventloop"

#: ../../users/explain/interactive_guide.rst:395
msgid "CPython / readline"
msgstr "CPython / readline"

#: ../../users/explain/interactive_guide.rst:397
msgid "The Python C API provides a hook, :c:data:`PyOS_InputHook`, to register a function to be run (\"The function will be called when Python's interpreter prompt is about to become idle and wait for user input from the terminal.\").  This hook can be used to integrate a second event loop (the GUI event loop) with the python input prompt loop. The hook functions typically exhaust all pending events on the GUI event queue, run the main loop for a short fixed amount of time, or run the event loop until a key is pressed on stdin."
msgstr "La API de Python C proporciona un hook, :c:data:`PyOS_InputHook`, para registrar una función que se ejecutará (\"La función será llamada cuando el intérprete de Python esté a punto de quedar inactivo y esperar la entrada del usuario desde el terminal\").  Este hook puede utilizarse para integrar un segundo bucle de eventos (el bucle de eventos de la GUI) con el bucle del prompt de entrada de Python. Las funciones hook normalmente agotan todos los eventos pendientes en la cola de eventos de la GUI, ejecutan el bucle principal durante un corto período de tiempo fijo, o ejecutan el bucle de eventos hasta que se pulsa una tecla en stdin."

#: ../../users/explain/interactive_guide.rst:406
msgid "Matplotlib does not currently do any management of :c:data:`PyOS_InputHook` due to the wide range of ways that Matplotlib is used.  This management is left to downstream libraries -- either user code or the shell.  Interactive figures, even with Matplotlib in 'interactive mode', may not work in the vanilla python repl if an appropriate :c:data:`PyOS_InputHook` is not registered."
msgstr "Matplotlib no hace actualmente ninguna gestión de :c:data:`PyOS_InputHook` debido a la amplia gama de formas en las que se utiliza Matplotlib.  Esta gestión se deja a las bibliotecas derivadas -- ya sea el código del usuario o el shell.  Las figuras interactivas, incluso con Matplotlib en 'modo interactivo', pueden no funcionar en la réplica de vanilla python si no se registra un :c:data:`PyOS_InputHook` apropiado."

#: ../../users/explain/interactive_guide.rst:412
msgid "Input hooks, and helpers to install them, are usually included with the python bindings for GUI toolkits and may be registered on import. IPython also ships input hook functions for all of the GUI frameworks Matplotlib supports which can be installed via ``%matplotlib``.  This is the recommended method of integrating Matplotlib and a prompt."
msgstr "Los hooks de entrada, y los ayudantes para instalarlos, suelen incluirse con los enlaces de python para los conjuntos de herramientas de interfaz gráfica de usuario y pueden registrarse al importarlos. IPython también incluye funciones hook de entrada para todos los marcos de trabajo GUI que Matplotlib soporta y que pueden ser instalados a través de ``%matplotlib``.  Este es el método recomendado para integrar Matplotlib y un prompt."

#: ../../users/explain/interactive_guide.rst:420
msgid "IPython / prompt_toolkit"
msgstr "IPython / prompt_toolkit"

#: ../../users/explain/interactive_guide.rst:422
msgid "With IPython >= 5.0 IPython has changed from using CPython's readline based prompt to a ``prompt_toolkit`` based prompt.  ``prompt_toolkit`` has the same conceptual input hook, which is fed into ``prompt_toolkit`` via the :meth:`IPython.terminal.interactiveshell.TerminalInteractiveShell.inputhook` method.  The source for the ``prompt_toolkit`` input hooks lives at :mod:`IPython.terminal.pt_inputhooks`."
msgstr "Con IPython >= 5.0 IPython ha cambiado de usar el prompt basado en readline de CPython a un prompt basado en ``prompt_toolkit``.  ``prompt_toolkit`` tiene el mismo hook de entrada conceptual, que se introduce en ``prompt_toolkit`` a través del método :meth:`IPython.terminal.interactiveshell.TerminalInteractiveShell.inputhook`.  La fuente de los hooks de entrada de ``prompt_toolkit`` se encuentran en :mod:`IPython.terminal.pt_inputhooks`."

#: ../../users/explain/interactive_guide.rst:432
msgid "Footnotes"
msgstr "Notas al pie"

#: ../../users/explain/interactive_guide.rst:433
msgid "A limitation of this design is that you can only wait for one input, if there is a need to multiplex between multiple sources then the loop would look something like ::"
msgstr "Una limitación de este diseño es que sólo puede esperar una entrada, si hay necesidad de hacer un multiplex entre múltiples fuentes entonces el bucle se vería algo como ::"

#: ../../users/explain/interactive_guide.rst:442
msgid "Or you can `write your own <https://www.youtube.com/watch?v=ZzfHjytDceU>`__ if you must."
msgstr "O puedes `escribir el tuyo propio <https://www.youtube.com/watch?v=ZzfHjytDceU>`__ si es necesario."

#: ../../users/explain/interactive_guide.rst:445
msgid "These examples are aggressively dropping many of the complexities that must be dealt with in the real world such as keyboard interrupts, timeouts, bad input, resource allocation and cleanup, etc."
msgstr "Estos ejemplos descartan de forma drástica muchas de las complejidades con las que hay que lidiar en el mundo real, como las interrupciones del teclado, los tiempos de espera, las entradas erróneas, la asignación y limpieza de recursos, etc."

