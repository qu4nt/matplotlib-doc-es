# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael
# Droettboom and the Matplotlib development team; 2012 - 2022 The Matplotlib
# development team
# This file is distributed under the same license as the Matplotlib package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Matplotlib 3.5.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-01 17:05-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../users/explain/interactive_guide.rst:10
msgid "Interactive figures and asynchronous programming"
msgstr ""

#: ../../users/explain/interactive_guide.rst:12
msgid ""
"Matplotlib supports rich interactive figures by embedding figures into a "
"GUI window.  The basic interactions of panning and zooming in an Axes to "
"inspect your data is 'baked in' to Matplotlib.  This is supported by a "
"full mouse and keyboard event handling system that you can use to build "
"sophisticated interactive graphs."
msgstr ""

#: ../../users/explain/interactive_guide.rst:18
msgid ""
"This guide is meant to be an introduction to the low-level details of how"
" Matplotlib integration with a GUI event loop works.  For a more "
"practical introduction to the Matplotlib event API see :ref:`event "
"handling system <event-handling-tutorial>`, `Interactive Tutorial "
"<https://github.com/matplotlib/interactive_tutorial>`__, and `Interactive"
" Applications using Matplotlib <http://www.amazon.com/Interactive-"
"Applications-using-Matplotlib-Benjamin/dp/1783988843>`__."
msgstr ""

#: ../../users/explain/interactive_guide.rst:27
msgid "Event loops"
msgstr ""

#: ../../users/explain/interactive_guide.rst:29
msgid ""
"Fundamentally, all user interaction (and networking) is implemented as an"
" infinite loop waiting for events from the user (via the OS) and then "
"doing something about it.  For example, a minimal Read Evaluate Print "
"Loop (REPL) is ::"
msgstr ""

#: ../../users/explain/interactive_guide.rst:42
msgid ""
"This is missing many niceties (for example, it exits on the first "
"exception!), but is representative of the event loops that underlie all "
"terminals, GUIs, and servers [#f1]_.  In general the *Read* step is "
"waiting on some sort of I/O -- be it user input or the network -- while "
"the *Evaluate* and *Print* are responsible for interpreting the input and"
" then **doing** something about it."
msgstr ""

#: ../../users/explain/interactive_guide.rst:49
msgid ""
"In practice we interact with a framework that provides a mechanism to "
"register callbacks to be run in response to specific events rather than "
"directly implement the I/O loop [#f2]_.  For example \"when the user "
"clicks on this button, please run this function\" or \"when the user hits"
" the 'z' key, please run this other function\".  This allows users to "
"write reactive, event-driven, programs without having to delve into the "
"nitty-gritty [#f3]_ details of I/O.  The core event loop is sometimes "
"referred to as \"the main loop\" and is typically started, depending on "
"the library, by methods with names like ``_exec``, ``run``, or ``start``."
msgstr ""

#: ../../users/explain/interactive_guide.rst:61
msgid ""
"All GUI frameworks (Qt, Wx, Gtk, tk, OSX, or web) have some method of "
"capturing user interactions and passing them back to the application (for"
" example ``Signal`` / ``Slot`` framework in Qt) but the exact details "
"depend on the toolkit.  Matplotlib has a :ref:`backend <what-"
"is-a-backend>` for each GUI toolkit we support which uses the toolkit API"
" to bridge the toolkit UI events into Matplotlib's :ref:`event handling "
"system <event-handling-tutorial>`.  You can then use "
"`.FigureCanvasBase.mpl_connect` to connect your function to Matplotlib's "
"event handling system.  This allows you to directly interact with your "
"data and write GUI toolkit agnostic user interfaces."
msgstr ""

#: ../../users/explain/interactive_guide.rst:77
msgid "Command prompt integration"
msgstr ""

#: ../../users/explain/interactive_guide.rst:79
msgid ""
"So far, so good.  We have the REPL (like the IPython terminal) that lets "
"us interactively send code to the interpreter and get results back.  We "
"also have the GUI toolkit that runs an event loop waiting for user input "
"and lets us register functions to be run when that happens.  However, if "
"we want to do both we have a problem: the prompt and the GUI event loop "
"are both infinite loops that each think *they* are in charge!  In order "
"for both the prompt and the GUI windows to be responsive we need a method"
" to allow the loops to 'timeshare' :"
msgstr ""

#: ../../users/explain/interactive_guide.rst:88
msgid ""
"let the GUI main loop block the python process when you want interactive "
"windows"
msgstr ""

#: ../../users/explain/interactive_guide.rst:90
msgid ""
"let the CLI main loop block the python process and intermittently run the"
" GUI loop"
msgstr ""

#: ../../users/explain/interactive_guide.rst:92
msgid ""
"fully embed python in the GUI (but this is basically writing a full "
"application)"
msgstr ""

#: ../../users/explain/interactive_guide.rst:98
msgid "Blocking the prompt"
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid ":py:obj:`pyplot.show <matplotlib.pyplot.show>`"
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid "Display all open figures."
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid ":py:obj:`pyplot.pause <matplotlib.pyplot.pause>`"
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid "Run the GUI event loop for *interval* seconds."
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
msgid ""
":py:obj:`backend_bases.FigureCanvasBase.start_event_loop "
"<matplotlib.backend_bases.FigureCanvasBase.start_event_loop>`"
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
msgid "Start a blocking event loop."
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
msgid ""
":py:obj:`backend_bases.FigureCanvasBase.stop_event_loop "
"<matplotlib.backend_bases.FigureCanvasBase.stop_event_loop>`"
msgstr ""

#: ../../users/explain/interactive_guide.rst:110:<autosummary>:1
msgid "Stop the current blocking event loop."
msgstr ""

#: ../../users/explain/interactive_guide.rst:111
msgid ""
"The simplest \"integration\" is to start the GUI event loop in 'blocking'"
" mode and take over the CLI.  While the GUI event loop is running you can"
" not enter new commands into the prompt (your terminal may echo the "
"characters typed into the terminal, but they will not be sent to the "
"Python interpreter because it is busy running the GUI event loop), but "
"the figure windows will be responsive.  Once the event loop is stopped "
"(leaving any still open figure windows non-responsive) you will be able "
"to use the prompt again.  Re-starting the event loop will make any open "
"figure responsive again (and will process any queued up user "
"interaction)."
msgstr ""

#: ../../users/explain/interactive_guide.rst:122
msgid ""
"To start the event loop until all open figures are closed, use "
"`.pyplot.show` as ::"
msgstr ""

#: ../../users/explain/interactive_guide.rst:127
msgid ""
"To start the event loop for a fixed amount of time (in seconds) use "
"`.pyplot.pause`."
msgstr ""

#: ../../users/explain/interactive_guide.rst:130
msgid ""
"If you are not using `.pyplot` you can start and stop the event loops via"
" `.FigureCanvasBase.start_event_loop` and "
"`.FigureCanvasBase.stop_event_loop`. However, in most contexts where you "
"would not be using `.pyplot` you are embedding Matplotlib in a large GUI "
"application and the GUI event loop should already be running for the "
"application."
msgstr ""

#: ../../users/explain/interactive_guide.rst:137
msgid ""
"Away from the prompt, this technique can be very useful if you want to "
"write a script that pauses for user interaction, or displays a figure "
"between polling for additional data.  See :ref:`interactive_scripts` for "
"more details."
msgstr ""

#: ../../users/explain/interactive_guide.rst:144
msgid "Input hook integration"
msgstr ""

#: ../../users/explain/interactive_guide.rst:146
msgid ""
"While running the GUI event loop in a blocking mode or explicitly "
"handling UI events is useful, we can do better!  We really want to be "
"able to have a usable prompt **and** interactive figure windows."
msgstr ""

#: ../../users/explain/interactive_guide.rst:150
msgid ""
"We can do this using the 'input hook' feature of the interactive prompt."
"  This hook is called by the prompt as it waits for the user to type "
"(even for a fast typist the prompt is mostly waiting for the human to "
"think and move their fingers).  Although the details vary between prompts"
" the logic is roughly"
msgstr ""

#: ../../users/explain/interactive_guide.rst:156
msgid "start to wait for keyboard input"
msgstr ""

#: ../../users/explain/interactive_guide.rst:157
msgid "start the GUI event loop"
msgstr ""

#: ../../users/explain/interactive_guide.rst:158
msgid "as soon as the user hits a key, exit the GUI event loop and handle the key"
msgstr ""

#: ../../users/explain/interactive_guide.rst:159
msgid "repeat"
msgstr ""

#: ../../users/explain/interactive_guide.rst:161
msgid ""
"This gives us the illusion of simultaneously having interactive GUI "
"windows and an interactive prompt.  Most of the time the GUI event loop "
"is running, but as soon as the user starts typing the prompt takes over "
"again."
msgstr ""

#: ../../users/explain/interactive_guide.rst:166
msgid ""
"This time-share technique only allows the event loop to run while python "
"is otherwise idle and waiting for user input.  If you want the GUI to be "
"responsive during long running code it is necessary to periodically flush"
" the GUI event queue as described :ref:`above <spin_event_loop>`.  In "
"this case it is your code, not the REPL, which is blocking the process so"
" you need to handle the \"time-share\" manually. Conversely, a very slow "
"figure draw will block the prompt until it finishes drawing."
msgstr ""

#: ../../users/explain/interactive_guide.rst:176
msgid "Full embedding"
msgstr ""

#: ../../users/explain/interactive_guide.rst:178
msgid ""
"It is also possible to go the other direction and fully embed figures "
"(and a `Python interpreter "
"<https://docs.python.org/3/extending/embedding.html>`__) in a rich native"
" application.  Matplotlib provides classes for each toolkit which can be "
"directly embedded in GUI applications (this is how the built-in windows "
"are implemented!).  See :ref:`user_interfaces` for more details."
msgstr ""

#: ../../users/explain/interactive_guide.rst:190
msgid "Scripts and functions"
msgstr ""

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:252:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid ""
":py:obj:`backend_bases.FigureCanvasBase.flush_events "
"<matplotlib.backend_bases.FigureCanvasBase.flush_events>`"
msgstr ""

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:252:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid "Flush the GUI events for the figure."
msgstr ""

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:252:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid ""
":py:obj:`backend_bases.FigureCanvasBase.draw_idle "
"<matplotlib.backend_bases.FigureCanvasBase.draw_idle>`"
msgstr ""

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:252:<autosummary>:1
#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid "Request a widget redraw once control returns to the GUI event loop."
msgstr ""

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid ":py:obj:`figure.Figure.ginput <matplotlib.figure.Figure.ginput>`"
msgstr ""

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid "Blocking call to interact with a figure."
msgstr ""

#: ../../users/explain/interactive_guide.rst:205:<autosummary>:1
msgid ":py:obj:`pyplot.ginput <matplotlib.pyplot.ginput>`"
msgstr ""

#: ../../users/explain/interactive_guide.rst:206
msgid "There are several use-cases for using interactive figures in scripts:"
msgstr ""

#: ../../users/explain/interactive_guide.rst:208
msgid "capture user input to steer the script"
msgstr ""

#: ../../users/explain/interactive_guide.rst:209
msgid "progress updates as a long running script progresses"
msgstr ""

#: ../../users/explain/interactive_guide.rst:210
msgid "streaming updates from a data source"
msgstr ""

#: ../../users/explain/interactive_guide.rst:213
msgid "Blocking functions"
msgstr ""

#: ../../users/explain/interactive_guide.rst:215
msgid ""
"If you only need to collect points in an Axes you can use "
"`.figure.Figure.ginput` or more generally the tools from "
"`.blocking_input` the tools will take care of starting and stopping the "
"event loop for you.  However if you have written some custom event "
"handling or are using `.widgets` you will need to manually run the GUI "
"event loop using the methods described :ref:`above "
"<cp_block_the_prompt>`."
msgstr ""

#: ../../users/explain/interactive_guide.rst:222
msgid ""
"You can also use the methods described in :ref:`cp_block_the_prompt` to "
"suspend run the GUI event loop.  Once the loop exits your code will "
"resume.  In general, any place you would use `time.sleep` you can use "
"`.pyplot.pause` instead with the added benefit of interactive figures."
msgstr ""

#: ../../users/explain/interactive_guide.rst:227
msgid "For example, if you want to poll for data you could use something like ::"
msgstr ""

#: ../../users/explain/interactive_guide.rst:237
msgid "which would poll for new data and update the figure at 1Hz."
msgstr ""

#: ../../users/explain/interactive_guide.rst:242
msgid "Explicitly spinning the event Loop"
msgstr ""

#: ../../users/explain/interactive_guide.rst:253
msgid ""
"If you have open windows that have pending UI events (mouse clicks, "
"button presses, or draws) you can explicitly process those events by "
"calling `.FigureCanvasBase.flush_events`. This will run the GUI event "
"loop until all UI events currently waiting have been processed.  The "
"exact behavior is backend-dependent but typically events on all figure "
"are processed and only events waiting to be processed (not those added "
"during processing) will be handled."
msgstr ""

#: ../../users/explain/interactive_guide.rst:261
msgid "For example ::"
msgstr ""

#: ../../users/explain/interactive_guide.rst:281
msgid ""
"While this will feel a bit laggy (as we are only processing user input "
"every 100ms whereas 20-30ms is what feels \"responsive\") it will "
"respond."
msgstr ""

#: ../../users/explain/interactive_guide.rst:285
msgid ""
"If you make changes to the plot and want it re-rendered you will need to "
"call `~.FigureCanvasBase.draw_idle` to request that the canvas be re-"
"drawn.  This method can be thought of *draw_soon* in analogy to "
"`asyncio.loop.call_soon`."
msgstr ""

#: ../../users/explain/interactive_guide.rst:290
msgid "We can add this our example above as ::"
msgstr ""

#: ../../users/explain/interactive_guide.rst:304
msgid ""
"The more frequently you call `.FigureCanvasBase.flush_events` the more "
"responsive your figure will feel but at the cost of spending more "
"resources on the visualization and less on your computation."
msgstr ""

#: ../../users/explain/interactive_guide.rst:312
msgid "Stale artists"
msgstr ""

#: ../../users/explain/interactive_guide.rst:314
msgid ""
"Artists (as of Matplotlib 1.5) have a **stale** attribute which is `True`"
" if the internal state of the artist has changed since the last time it "
"was rendered. By default the stale state is propagated up to the Artists "
"parents in the draw tree, e.g., if the color of a `.Line2D` instance is "
"changed, the `.axes.Axes` and `.figure.Figure` that contain it will also "
"be marked as \"stale\".  Thus, ``fig.stale`` will report if any artist in"
" the figure has been modified and is out of sync with what is displayed "
"on the screen.  This is intended to be used to determine if ``draw_idle``"
" should be called to schedule a re-rendering of the figure."
msgstr ""

#: ../../users/explain/interactive_guide.rst:325
msgid ""
"Each artist has a `.Artist.stale_callback` attribute which holds a "
"callback with the signature ::"
msgstr ""

#: ../../users/explain/interactive_guide.rst:331
msgid ""
"which by default is set to a function that forwards the stale state to "
"the artist's parent.   If you wish to suppress a given artist from "
"propagating set this attribute to None."
msgstr ""

#: ../../users/explain/interactive_guide.rst:335
msgid ""
"`.figure.Figure` instances do not have a containing artist and their "
"default callback is `None`.  If you call `.pyplot.ion` and are not in "
"``IPython`` we will install a callback to invoke "
"`~.backend_bases.FigureCanvasBase.draw_idle` whenever the "
"`.figure.Figure` becomes stale.  In ``IPython`` we use the "
"``'post_execute'`` hook to invoke "
"`~.backend_bases.FigureCanvasBase.draw_idle` on any stale figures after "
"having executed the user's input, but before returning the prompt to the "
"user.  If you are not using `.pyplot` you can use the callback "
"`Figure.stale_callback` attribute to be notified when a figure has become"
" stale."
msgstr ""

#: ../../users/explain/interactive_guide.rst:351
msgid "Idle draw"
msgstr ""

#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid ""
":py:obj:`backend_bases.FigureCanvasBase.draw "
"<matplotlib.backend_bases.FigureCanvasBase.draw>`"
msgstr ""

#: ../../users/explain/interactive_guide.rst:361:<autosummary>:1
msgid "Render the `.Figure`."
msgstr ""

#: ../../users/explain/interactive_guide.rst:362
msgid ""
"In almost all cases, we recommend using "
"`backend_bases.FigureCanvasBase.draw_idle` over "
"`backend_bases.FigureCanvasBase.draw`.  ``draw`` forces a rendering of "
"the figure whereas ``draw_idle`` schedules a rendering the next time the "
"GUI window is going to re-paint the screen.  This improves performance by"
" only rendering pixels that will be shown on the screen.  If you want to "
"be sure that the screen is updated as soon as possible do ::"
msgstr ""

#: ../../users/explain/interactive_guide.rst:376
msgid "Threading"
msgstr ""

#: ../../users/explain/interactive_guide.rst:378
msgid ""
"Most GUI frameworks require that all updates to the screen, and hence "
"their main event loop, run on the main thread.  This makes pushing "
"periodic updates of a plot to a background thread impossible. Although it"
" seems backwards, it is typically easier to push your computations to a "
"background thread and periodically update the figure on the main thread."
msgstr ""

#: ../../users/explain/interactive_guide.rst:385
msgid ""
"In general Matplotlib is not thread safe.  If you are going to update "
"`.Artist` objects in one thread and draw from another you should make "
"sure that you are locking in the critical sections."
msgstr ""

#: ../../users/explain/interactive_guide.rst:392
msgid "Eventloop integration mechanism"
msgstr ""

#: ../../users/explain/interactive_guide.rst:395
msgid "CPython / readline"
msgstr ""

#: ../../users/explain/interactive_guide.rst:397
msgid ""
"The Python C API provides a hook, :c:data:`PyOS_InputHook`, to register a"
" function to be run (\"The function will be called when Python's "
"interpreter prompt is about to become idle and wait for user input from "
"the terminal.\").  This hook can be used to integrate a second event loop"
" (the GUI event loop) with the python input prompt loop. The hook "
"functions typically exhaust all pending events on the GUI event queue, "
"run the main loop for a short fixed amount of time, or run the event loop"
" until a key is pressed on stdin."
msgstr ""

#: ../../users/explain/interactive_guide.rst:406
msgid ""
"Matplotlib does not currently do any management of "
":c:data:`PyOS_InputHook` due to the wide range of ways that Matplotlib is"
" used.  This management is left to downstream libraries -- either user "
"code or the shell.  Interactive figures, even with Matplotlib in "
"'interactive mode', may not work in the vanilla python repl if an "
"appropriate :c:data:`PyOS_InputHook` is not registered."
msgstr ""

#: ../../users/explain/interactive_guide.rst:412
msgid ""
"Input hooks, and helpers to install them, are usually included with the "
"python bindings for GUI toolkits and may be registered on import. IPython"
" also ships input hook functions for all of the GUI frameworks Matplotlib"
" supports which can be installed via ``%matplotlib``.  This is the "
"recommended method of integrating Matplotlib and a prompt."
msgstr ""

#: ../../users/explain/interactive_guide.rst:420
msgid "IPython / prompt_toolkit"
msgstr ""

#: ../../users/explain/interactive_guide.rst:422
msgid ""
"With IPython >= 5.0 IPython has changed from using CPython's readline "
"based prompt to a ``prompt_toolkit`` based prompt.  ``prompt_toolkit`` "
"has the same conceptual input hook, which is fed into ``prompt_toolkit`` "
"via the "
":meth:`IPython.terminal.interactiveshell.TerminalInteractiveShell.inputhook`"
" method.  The source for the ``prompt_toolkit`` input hooks lives at "
":mod:`IPython.terminal.pt_inputhooks`."
msgstr ""

#: ../../users/explain/interactive_guide.rst:432
msgid "Footnotes"
msgstr ""

#: ../../users/explain/interactive_guide.rst:433
msgid ""
"A limitation of this design is that you can only wait for one input, if "
"there is a need to multiplex between multiple sources then the loop would"
" look something like ::"
msgstr ""

#: ../../users/explain/interactive_guide.rst:442
msgid ""
"Or you can `write your own "
"<https://www.youtube.com/watch?v=ZzfHjytDceU>`__ if you must."
msgstr ""

#: ../../users/explain/interactive_guide.rst:445
msgid ""
"These examples are aggressively dropping many of the complexities that "
"must be dealt with in the real world such as keyboard interrupts, "
"timeouts, bad input, resource allocation and cleanup, etc."
msgstr ""

